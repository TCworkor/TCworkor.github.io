<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>TCworker • Posts by &#34;理论知识&#34; category</title>
        <link>http://example.com</link>
        <description>time to work</description>
        <language>zh-CN</language>
        <pubDate>Mon, 09 Jan 2023 14:21:02 +0800</pubDate>
        <lastBuildDate>Mon, 09 Jan 2023 14:21:02 +0800</lastBuildDate>
        <category>csapp</category>
        <category>闲暇</category>
        <category>Linux</category>
        <category>图床</category>
        <category>Typroa</category>
        <category>blog</category>
        <category>hexo</category>
        <category>python</category>
        <category>pwn</category>
        <category>指针</category>
        <category>C语言</category>
        <item>
            <guid isPermalink="true">http://example.com/2023/01/09/csapp%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20I/</guid>
            <title>csapp 第三章 I</title>
            <link>http://example.com/2023/01/09/csapp%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20I/</link>
            <category>csapp</category>
            <pubDate>Mon, 09 Jan 2023 14:21:02 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;csapp-第三章-i&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#csapp-第三章-i&#34;&gt;#&lt;/a&gt; csapp 第三章 I&lt;/h1&gt;
&lt;h1 id=&#34;前置点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#前置点&#34;&gt;#&lt;/a&gt; 前置点：&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;机器语言&lt;/code&gt; 是计算机能直接运行的语言，是二进制语言，属于低级语言； &lt;code&gt;汇编语言&lt;/code&gt; 是面向机器的低级语言，不能被机器直接识别，需要编译； &lt;code&gt;高级语言&lt;/code&gt; 是从人类的逻辑思维角度出发的计算机语言，不能被机器直接识别，需要编译。&lt;!--换言之，机器语言和汇编语言所面向的机器，是为机器服务的；而高级语言是为了便于人开展工作，是为程序员服务的。--&gt;&lt;/p&gt;
&lt;p&gt;计算机语言具有高级语言和低级语言之分。而高级语言又主要是相对于汇编语言而言的，它是较接近自然语言和数学公式的编程，基本脱离了机器的硬件系统，用人们更易理解的方式编写程序。&lt;/p&gt;
&lt;p&gt;低级语言分机器语言（二进制语言）和汇编语言（符号语言），这两种语言都是面向机器的语言，和具体机器的指令系统密切相关。机器语言用指令代码编写程序，而符号语言用指令助记符来编写程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;机器语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;机器语言是一种指令集的体系，它是用二进制代码表示的语言，是计算机唯一可以&lt;u&gt;直接识别和执行&lt;/u&gt;的语言，它具有计算机可以直接执行、简洁、运算速度快等优点，但它的直观性差 (其实是相当差，毕竟没人会喜欢满屏幕的 0 和 1)，非常容易出错，程序的检查和调试都比较困难，此外对机器的&lt;u&gt;依赖型&lt;/u&gt;也很强。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;汇编语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;汇编语言是面向机器的程序设计语言，它是为了解决机器语言难以理解和记忆的缺点，用易于理解和记忆的名称和符号表示机器指令中的操作码，这样用符号代替机器语言的二进制码，就把机器语言变成了汇编语言；于是汇编语言亦称为符号语言。&lt;!--汇编语言用简易的名称和符号来表示操作码，这使得代码的编写和检查提供了巨大的便捷--&gt;&lt;/p&gt;
&lt;p&gt;使用汇编语言编写的程序，机器&lt;u&gt;不能直接识别&lt;/u&gt;，要由一种程序将汇编语言翻译成机器语言，这种起翻译作用的程序叫汇编程序，汇编程序是系统软件中语言处理系统软件。汇编程序把汇编语言翻译成机器语言的过程称为汇编。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高级语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;高级语言为用户提供了一种既接近于自然语言，又可以使用数学表达式，还相对独立于机器的工作方式。与汇编语言一样，机器也不能直接执行用高级语言编写的程序。&lt;!--牛蛙--&gt;&lt;/p&gt;
&lt;p&gt;而高级语言并不是特指的某一种具体的语言，而是包括很多编程语言，如目前流行的 java，c，c++，C#，pascal，python 等等。&lt;!--听说掌握七门甚至六门高级语言，就可以召唤神龙（bushi）--&gt;&lt;/p&gt;
&lt;p&gt;高级语言有更强的表达能力，可方便地表示数据的运算和程序的控制结构，能更好的描述各种算法，而且容易学习掌握。但它编译生成的程序代码一般比用汇编程序语言设计的程序代码要长，执行的速度也慢。&lt;/p&gt;
&lt;h1 id=&#34;31-历史观点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#31-历史观点&#34;&gt;#&lt;/a&gt; 3.1 历史观点&lt;/h1&gt;
&lt;p&gt;全是图片😕, 毕竟我不是历史学家。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202301081146247.bmp&#34; alt=&#34;capture_20230108114407972&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202301081146870.bmp&#34; alt=&#34;capture_20230108114433881&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202301081147348.bmp&#34; alt=&#34;capture_20230108114521435&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202301081148541.bmp&#34; alt=&#34;capture_20230108114533692&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;32-程序编码&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#32-程序编码&#34;&gt;#&lt;/a&gt; 3.2 程序编码&lt;/h1&gt;
&lt;h2 id=&#34;a&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#a&#34;&gt;#&lt;/a&gt; A&lt;/h2&gt;
&lt;p&gt;代码的编译，一般使用第二级优化，因为这是性能和便捷度的最好的权衡 (具体的原有的话，现在我还不到)。实际上的编译是一个比较复杂的过程，有&lt;u&gt;预处理&lt;/u&gt;，&lt;u&gt;编译&lt;/u&gt;，&lt;u&gt;汇编&lt;/u&gt;，&lt;u&gt;链接&lt;/u&gt; 四个阶段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;预处理阶段&lt;/strong&gt;。预处理器（cpp）根据以字符 #开头的命令，修改原始的 C 程序。比如 hello.c 中第一行的 #include&amp;lt;stdio.h&amp;gt; 命令告诉预处理器读取系统头文件&lt;u&gt;stdio.h&lt;/u&gt;的内容，并把它直接插入程序文本中，结果就得到了另一个 C 程序，通常是以.i 作为文件扩展名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译阶段&lt;/strong&gt;。编译器（ccl）将文本文件 hello.i&lt;strong&gt; 翻译&lt;/strong&gt;成文本文件 hello.s，它包含一个汇编语言程序。&lt;u&gt;汇编语言程序中的每条语句都以一种标准的文本格式确切的描述了一条低级机器语言指令&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;汇编阶段&lt;/strong&gt;。汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种可重定位目标程序的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它的字节编码是机器语言指令而不是字符，如果我们在文本文件中打开 hello.o 文件，看到的将是一堆乱码。&lt;!--不可读性--&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链接阶段&lt;/strong&gt;。链接器（ld）负责处理合并目标代码，生成一个可执行目标文件，可以被加载到内存中，由系统执行。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;strong&gt;&lt;u&gt;tips：&lt;/u&gt;&lt;/strong&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顾名思义，&lt;strong&gt;源代码&lt;/strong&gt;是程序的源代码，是由程序员编写的&lt;u&gt;原始文件&lt;/u&gt;。源代码是人类可读的，但是机器无法直接理解它。而目标代码是机器可执行文件，其中包含由编译器生成的二进制形式的机器指令。源代码作为编译器的输入，而目标代码是编译器的输出，并且是一个二进制文件，具有程序员在源代码中给出的指令。&lt;/li&gt;
&lt;li&gt;目标代码是特定于系统体系结构的，即在一台计算机上由编译器生成的文件可能无法在具有不同系统体系结构或基础结构的其他计算机上运行。&lt;!--就是说，电脑不同的话，同一份目标代码可能无法运行--&gt;。并且，目标代码对应于源代码，所以修改源代码后，每次需要编译源代码以反映目标代码中的更改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;b&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#b&#34;&gt;#&lt;/a&gt; B&lt;/h2&gt;
&lt;p&gt;汇编代码接近于机械代码，其基本特点是具有良好的可读性，能够理解汇编代码以及它是如何与原始的 C 语言代码相对应的，是理解计算机如何执行程序的关键一步。&lt;!--可以说，机械代码是生黄瓜，汇编代码是腌黄瓜，两者相近，但后者风味更佳--&gt;【虽然对我来说，两种都不好吃🙄】&lt;/p&gt;
&lt;p&gt;通过了解汇编语言，可以了解到：一些通常对 C 程序员来说不可见的处理器的状态，比如程序计数器，整数计算器等的状态。相比于 C，汇编代码只是&lt;u&gt;简单地将存储器看成一个很大的、按字节寻址的数组&lt;/u&gt;。C 中的聚集数据类型，例如数组和结构，在汇编代码中&lt;u&gt;也是以连续的字节表示&lt;/u&gt;。而如果是对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，不区分指针和整数。&lt;!--注意两者的差异性，但很多时候还是通性居多--&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;程序存储器&lt;/em&gt;（program memory）包含程序的目标代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的存储器块（比如说用 malloc 库函数分配的）。😖&lt;/p&gt;
&lt;p&gt;&lt;em&gt;程序存储器&lt;/em&gt;是用&lt;u&gt;&lt;strong&gt;虚拟地址&lt;/strong&gt;&lt;/u&gt;来寻址的。在任意给定的时刻，只有有限的一部分虚拟地址是&lt;mark&gt;合法&lt;/mark&gt;的。例如，虽然 IA32 的 32 位地址可以寻址 4GB 的地址范围，但是一个通常的程序只会访问几 M 字节。操作系统负责管理虚拟地址空间，将虚拟地址转换成实际处理器存储器（processor memory）中的物理地址。&lt;!--这个合法应该不能咨询罗翔老师吧--&gt;&lt;/p&gt;
&lt;p&gt;&lt;u&gt;一条机器指令只执行非常基本的操作&lt;/u&gt;。例如，将两个存放在寄存器中的数字相加，在存储器和寄存器之间传递数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令序列，从而实现象算术表达式求值、循环或过程调用和返回这样的程序结构。&lt;/p&gt;
&lt;h2 id=&#34;c&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#c&#34;&gt;#&lt;/a&gt; C&lt;/h2&gt;
&lt;p&gt;假设我们写了一个 C 代码文件 code.c ，在命令行上使用 “—S” 选项，就能看到 C 编译器产生的&lt;mark&gt;汇编代码&lt;/mark&gt;：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;unix&amp;gt; gcc -02 -S code.c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;编译器会产生一个&lt;u&gt;汇编文件&lt;/u&gt; code.s，但是不做其他进一步的工作（通常情况下，它还会调用汇编器产生目标代码文件）。&lt;br&gt;
GCC 是按照它自己的格式产生汇编代码的，这种格式称为 GAS（Gnu ASsembler，GNU 汇编器）。这种格式同 Intel 文档中的格式以及微软编译器使用的格式&lt;mark&gt;差异很大&lt;/mark&gt;。&lt;br&gt;
汇编代码文件包含各种声明，包括下面所示：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sum:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;pushl %ebp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;movl %esp,%ebp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;movl 12(%ebp),%eax &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;addl 8(%ebp),%eax &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;addl %eax,accum&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;movl %ebp,%esp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;popl %ebp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ret&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中每个缩进去的行都对应于一条机器指令 (一一对应，依次执行)。比如，pushl 指令表示应该将寄存器％ebp 的内容压入程序栈中。这段代码中已经除去了所有关于局部变量名或数据类型的信息，但我们还是看到了一个对全局变量 accum 的引用，这是因为编译器还不能确定这个变量会放在存储器中的哪个位置。&lt;br&gt;
如果我们使用 “—c” 命令行选项，GCC 会&lt;u&gt;&lt;strong&gt;编译并汇编&lt;/strong&gt;&lt;/u&gt;该代码：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;unix&amp;gt; gcc -02-c code.c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这就会产生目标代码文件 code．o，它是二进制格式的，所以无法被我们直接读。852 字节的文件 code．o 中有一段 19 字节的十六进制表示的序列：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;55 89 e5 8b 45 0c 03 45 08 01 05 00 00 00 00 89 ec 5d c3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这就是对应于上面列出的&lt;strong&gt;汇编指令&lt;/strong&gt;的&lt;mark&gt;目标代码&lt;/mark&gt;。从中得到的重要信息就是：&lt;u&gt;机器实际执行的程序只是对一系列指令进行编码的字节序列。机器对产生这些指令的源代码几乎一无所知&lt;/u&gt;。&lt;!--正因如此，仅仅凭借目标代码是难以反推出源代码的--&gt;&lt;/p&gt;
&lt;p&gt;那么，如何找到程序的字节表示？😕&lt;br&gt;
首先，1. 我们用&lt;u&gt;&lt;strong&gt;反汇编器&lt;/strong&gt;&lt;/u&gt;来确定函数 sum 的代码长是 19 字节。2. 我们在文件 code.o 上运行 GNU 调试工具 GDB，输入命令：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb) x/19xb sum&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该命令会告诉&lt;strong&gt; GDB&lt;/strong&gt;&lt;u&gt;检查（简写为 “x”）19 个十六进制格式（也简写为 “x”）的字节（简写为 “b”）&lt;/u&gt;。你会发现，GDB 有很多有用的特性可以用来分析机器级程序。&amp;lt;!–虽然我感觉没怎么发现 -_—&amp;gt;&lt;/p&gt;
&lt;p&gt;要&lt;u&gt;查看&lt;/u&gt;目标代码文件的&lt;strong&gt;内容&lt;/strong&gt;，有一类称为&lt;mark&gt;反汇编器&lt;/mark&gt;（disassembler）的程序的可以实现，这些程序根据目标代码生成一种类似于汇编代码的格式 (有汇编器就一定有反汇编器的吧，这并不奇怪😃）， 在 Linux 系统中，带 “—d” 命令行选项的程序 OBJDUMP（代表 “object dump”）可以充当这个角色：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;unix&amp;gt; objdump -d code.o&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结果是（这里，我们在左边增加了行号，在右边增加了注解）：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202301082154615.bmp&#34; alt=&#34;capture_20230108215425729&#34;&gt;&lt;/p&gt;
&lt;p&gt;在左边，我们看到按照前面给出的字节顺序排列的 19 个十六进制字节值，它们分成了一些组，每组有 1～6 个字节。&lt;u&gt;&lt;strong&gt;每组都是一条指令，右边是等价的汇编语言&lt;/strong&gt;&lt;/u&gt;。其中一些特性值得说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IA32&lt;mark&gt; 指令长度&lt;/mark&gt;从 1～15 个字节不等。&lt;u&gt;&lt;strong&gt;指令编码被设计成使常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多&lt;/strong&gt;&lt;/u&gt;。【将常常出现的&lt;strong&gt;指令&lt;/strong&gt;趋于简化，这不难理解】&lt;/li&gt;
&lt;li&gt;指令格式是按照这样一种方式设计的，从某个&lt;mark&gt;给定位置&lt;/mark&gt;开始，&lt;u&gt;&lt;strong&gt;可以将字节惟一地解码成机器指令&lt;/strong&gt;&lt;/u&gt;(即使看起来目标代码很冗杂，但却是高度有序的)。例如，只有指令 pushl％ebp 是以字节值 55 开头的。&lt;/li&gt;
&lt;li&gt;&lt;u&gt;&lt;strong&gt;反汇编器&lt;/strong&gt;只是根据目标文件中的字节序列来确定汇编代码的&lt;/u&gt;。它&lt;strong&gt;不需要&lt;/strong&gt;访问程序的源代码或汇编代码。&lt;!--反汇编器是从目标代码出发，反推回汇编代码的哦--&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反汇编器&lt;/strong&gt;使用的&lt;u&gt;指令命名规则&lt;/u&gt;与 GAS 使用的有些细微的&lt;strong&gt;差别&lt;/strong&gt;。在我们的示例中，它省略了很多指令结尾的 “1”。&lt;/li&gt;
&lt;li&gt;&lt;u&gt;与 code.s 中的汇编代码相比，我们还发现结尾多了一条&lt;strong&gt; nop 指令&lt;/strong&gt;。这条指令根本&lt;mark&gt;不会被执行&lt;/mark&gt;&lt;/u&gt;&lt;/li&gt;
&lt;li&gt;它在过程返回指令之后，即使执行了也不会有任何影响（所以称之为 nop，是 “no operation” 的简写，通常读作 “noop”）。&lt;u&gt;编译器插入这样的指令是为了填充存储该过程的空间。&lt;/u&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;生成实际可执行的代码需要对一组&lt;strong&gt;目标代码文件&lt;/strong&gt;运行&lt;mark&gt;链接器&lt;/mark&gt;，而这一组目标代码文件中必须含有一个 **&lt;u&gt;main 函数&lt;/u&gt;**。假设在文件 main.c 中有下面这样的函数：&lt;!--链接，就像汽车生产过程中的最后部件组装一样吧，组装好了就可以上路了--&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;  int main() &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	return sum(1,3); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后，我们用如下方法生成可执行文件 test：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;unix&amp;gt; gcc -02 -o prog code.o main.c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;文件 prog 变成了 11667 字节，因为它不仅包含我们的两个过程的代码，还包含了用来启动和终&lt;/p&gt;
&lt;p&gt;止程序的信息，以及用来与操作系统交互的信息（把一切信息编织起来）。我们也可以反汇编 prog 文件：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;unix&amp;gt; objdump -d prog&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;反汇编器会抽取出各种代码序列，包括下面这段：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202301082202515.bmp&#34; alt=&#34;capture_20230108220110430&#34;&gt;&lt;/p&gt;
&lt;p&gt;注意，这段代码与 code.c 反汇编产生的代码几乎完全一样。一个主要的区别是左边列出的地址不同 (&lt;u&gt;链接器将代码的地址移到一段不同的地址范围&lt;/u&gt;)。第二个不同之处在于链接器终于确定存储全局变量 accum 的地址。code．o 反汇编代码的第 6 行中，accum 的地址还是 0。prog 的反汇编代码中，地址就设成 0x8049464。这可以从指令的汇编代码格式中看到，还可以从指令的最后四个字节中看出来，从最低位到最高位列出的就是 64940408。&lt;!-- 链接 会将代码的地址确定并改变--&gt;&lt;/p&gt;
&lt;h2 id=&#34;d&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#d&#34;&gt;#&lt;/a&gt; D&lt;/h2&gt;
&lt;p&gt;GCC 产生的汇编代码有点难读，它包含一些我们不需要关心的信息。另外，它不提供任何程序的描述或它是如何工作的描述。例如，假设文件 simple.c 包含下列代码：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;int simple(int *xp, int y) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	int t=*xp+y; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	*xp=t; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	return t; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当带选项 “—S” 运行 GCC 时，它产生下面的文件 simple.s：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;.file &amp;quot;simple.c&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;.version	&amp;quot;01.01&amp;quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;gcc2_compiled.: &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;.text&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  .align 4 &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;.globl simple &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; .type	simple,@function &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;simple:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; pushl %ebp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; mov1 %esp,&amp;amp;ebp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mov1 8(%ebp),%eax &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mov1 (%eax), %edx &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;add1	12(%ebp) , %edx &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mov1 %edx, (%eax)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mov1 %edx,%eax &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;movl %ebp,%esp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;popl %ebp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ret &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;.Lfe1: &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;.size	simple,.Lfel-simple &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;.ident	&amp;quot;GCC:(GNU) 2.95.3 20010315 (release)&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;文件包含的信息多于我们实际需要的。所有以 “.” 开头的行都是指导汇编器和链接器的命令（directive），不过我们&lt;u&gt;通常可以忽略这些行&lt;/u&gt;。另一方面，也没有关于这些指令是干什么用的以及它们与源代码之间关系的解释说明。😄&lt;/p&gt;
&lt;p&gt;为了更清楚地说明汇编代码，我们将给出汇编代码的&lt;mark&gt;格式&lt;/mark&gt;，包括 **&lt;u&gt;行号和解释性说明&lt;/u&gt;**。对于我们的示例，带解释的汇编代码是像下面这样的：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;simple: &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;pushl %ebp	Save frame pointer &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;movl %esp,%ebp	Create new frame pointer &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mov1 8(%ebp), %eax	Get xp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;movl (%eax),&amp;amp;edx	Retrieve*xp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;addl 12(%ebp),%edx	Add y to get t &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mov1 %edx, (%eax)	Store t at *xp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mov1 %edx,%eax	Set t as return value &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;movl %ebp,%esp	Reset stack pointer &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;popl %ebp	Reset frame pointer&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ret			Return&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通常我们只会给出与要讨论内容相关的代码行。每一行的左边都有编号供引用，右边是注释，简单地描述指令的效果以及它与原始 C 代码中的计算操作的关系。这是一种汇编语言程序员写代码的风格。&lt;/p&gt;
&lt;h1 id=&#34;33-数据格式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#33-数据格式&#34;&gt;#&lt;/a&gt; 3.3  数据格式&lt;/h1&gt;
&lt;p&gt;由于是从 16 位体系结构扩展成 32 位的，Intel 用术语 ==“字（word）”&lt;mark&gt; 表示&lt;strong&gt; 16 位数据类型&lt;/strong&gt;。因此，&lt;br&gt;
称&lt;strong&gt; 32 位数&lt;/strong&gt;为&lt;/mark&gt; “双字（doublewords）”&lt;mark&gt;，称&lt;strong&gt; 64 位数&lt;/strong&gt;为&lt;/mark&gt; “四字（quadwords）”==。我们将遇到的大多数指&lt;br&gt;
令都是对字节或双字操作的。&lt;/p&gt;
&lt;p&gt;图 3.1 给出了对应 C 基本数据类型的机器表示。注意，&lt;u&gt;大多数常用数据类型都是作为&lt;strong&gt;双字&lt;/strong&gt;存储&lt;/u&gt;&lt;br&gt;
&lt;u&gt;的&lt;/u&gt;。其中，包括普通整数（int）和长整数（longint），无论它们是否有符号。此外，所有的指针（在&lt;br&gt;
此用 char * 表示）&lt;strong&gt;都是 4 字节的双字&lt;/strong&gt;。处理字符串数据时，通常用到字节。浮点数有三种形式：单&lt;br&gt;
精度（4 字节）值，对应于 C 数据类型 foat；双精度（8 字节）值，对应于 C 数据类型 double：和&lt;br&gt;
扩展精度（10 字节）值。GCC 用数据类型 1ongdouble 来表示扩展精度的浮点值。为了提高存储器&lt;br&gt;
系统的性能，它将这样的浮点数存储成 12 字节数，待会儿我们会讨论这个问题。虽然 ANSIC 标准&lt;br&gt;
包括 longdouble 数据类型，但是对大多数编译器和机器组合来说，它的实现和普通 double 的 8 字节&lt;br&gt;
格式是一样的。对 GCC 和 IA32 的组合来说，支持扩展精度是很少见的。&lt;!--这些知识是我们比较熟悉的，也不会有太多的困惑感--&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202301082151608.bmp&#34; alt=&#34;capture_20230108175905491&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图 3.1 所示，&lt;strong&gt;&lt;u&gt;GAS 中的每个操作都有一个字符后级，表明操作数的大小&lt;/u&gt;&lt;/strong&gt;。例如，mov（传送&lt;br&gt;
数据）指令有三种形式：&lt;mark&gt;movb（传送字节）、movw（传送字）和 movl（传送双字）&lt;/mark&gt;。后缀 ==“1”&lt;mark&gt; 用来&lt;br&gt;
表示双字，因为在许多机器上，32 位数都称为&lt;/mark&gt; “长字（longword）”&lt;mark&gt;，这是沿用以 16 位字为标准的&lt;br&gt;
程序的机器级表示时代的习惯造成的。&lt;u&gt;注意，GAS 使用后缀&lt;/u&gt;&lt;/mark&gt; “1”== 来同时表示 4 字节的整数和 8 字节的双精度浮点数。这不会产生岐义，因为 **&lt;u&gt;浮点数使用的是一组完全不同的指令和寄存器。&lt;/u&gt;**&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/11/24/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88(1)/</guid>
            <title>C语言指针(1)</title>
            <link>http://example.com/2022/11/24/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88(1)/</link>
            <category>指针</category>
            <category>C语言</category>
            <pubDate>Thu, 24 Nov 2022 23:51:02 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;一指针简介&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一指针简介&#34;&gt;#&lt;/a&gt; 一。指针简介&lt;/h2&gt;
&lt;p&gt;指针是  &lt;code&gt;C&lt;/code&gt;  语言的灵魂，它不仅仅是 C 语言中的一个重要概念及其特点，也是 C 语言比较困难的部分。指针也就是 &lt;code&gt;内存地址&lt;/code&gt; ，指针变量是用来&lt;u&gt;存放&lt;strong&gt;内存地址&lt;/strong&gt;的变量&lt;/u&gt;，不同类型的指针变量所占用的存储单元长度是&lt;strong&gt;相同的&lt;/strong&gt; (毕竟只是一个地址)，而存放数据的变量因数据的类型不同，所占用的存储空间长度也&lt;strong&gt;不同&lt;/strong&gt;。【其实就像酒店的房间，房间的 &lt;mark&gt;&lt;strong&gt;门牌号&lt;/strong&gt;&lt;/mark&gt; (指针 \ &lt;u&gt;内存地址&lt;/u&gt;) 可以都是三位数 如 803 .  012，但是 &lt;mark&gt;&lt;strong&gt;房间类型&lt;/strong&gt;&lt;/mark&gt; (不同数据类型的&lt;u&gt;储存空间长度&lt;/u&gt;) 可以随着住户的需求而改变，像 单人间 ， 双人间 ，杂物间？】&lt;/p&gt;
&lt;p&gt;合理的使用指针可以提高效率。&lt;/p&gt;
&lt;p&gt;合理的使用指针可以提高灵活度。&lt;/p&gt;
&lt;p&gt;不合理的使用指针就会大 (吉) 寄大 (利) 历；&lt;/p&gt;
&lt;p&gt;因为指针是一把&lt;mark&gt;双刃剑&lt;/mark&gt;，如果对指针不能正确理解和灵活有效的应用，利用指针编写的程序也很容易发生各式各样的错误，同时程序的可读性也会大打折扣。所以指针的使用，不是 &lt;strong&gt;吉&lt;/strong&gt;，就是 &lt;strong&gt;寄&lt;/strong&gt;。至于是吉还是寄，就看诸位的功底了。}&lt;/p&gt;
&lt;h3 id=&#34;1内存&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1内存&#34;&gt;#&lt;/a&gt; 1. 内存&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;C&lt;/code&gt;  语言所有的变量都存放在内存中，每个人都有它的归宿， 而各种变量如 int ,char … ，它们的归宿就是内存，总之嘛，&lt;strong&gt;内存作为容器用来存放变量&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;2内存地址&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2内存地址&#34;&gt;#&lt;/a&gt; 2. 内存地址&lt;/h3&gt;
&lt;p&gt;内存地址就好比一个人的身份证，每个人的身份证都是唯一的，&lt;strong&gt;内存地址也是唯一的&lt;/strong&gt;，可以通过唯一的内存地址，找到唯一的内存数据。&lt;/p&gt;
&lt;h3 id=&#34;3指针声明&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#3指针声明&#34;&gt;#&lt;/a&gt; 3. 指针声明&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;指针&lt;/code&gt; 也是  &lt;code&gt;C&lt;/code&gt;  语言中变量的一种，其值为一个 &lt;strong&gt;变量&lt;/strong&gt; 的地址，即内存位置的直接地址。指针变量声明的一般形式为：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202211232327103.jpeg&#34; alt=&#34;网页捕获_23-11-2022_231934_www.jianshu.com&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：请不要忘记在指针类型和变量名中间有一个  &lt;code&gt;*&lt;/code&gt;  号哦，没有这个  &lt;code&gt;*&lt;/code&gt;  号的话，只是定义了一个普通变量，这也是普通变量声明和指针声明的区别之一；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202211232331683.jpeg&#34; alt=&#34;网页捕获_23-11-2022_23208_www.jianshu.com&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;二指针类型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#二指针类型&#34;&gt;#&lt;/a&gt; 二。指针类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;指针很灵活，它可以指向任意类型的数据。 &lt;code&gt;指针&lt;/code&gt; 的类型说明了它所指向  &lt;u&gt;地址空间 &lt;/u&gt; 的内存&lt;/strong&gt;，以下是有效的指针声明：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202211232333259.jpeg&#34; alt=&#34;网页捕获_23-11-2022_232038_www.jianshu.com&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;三声明并初始化一个指针&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#三声明并初始化一个指针&#34;&gt;#&lt;/a&gt; 三。声明并初始化一个指针&lt;/h2&gt;
&lt;h3 id=&#34;1声明指针并直接初始化&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1声明指针并直接初始化&#34;&gt;#&lt;/a&gt; 1. 声明指针并直接初始化&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202211232334098.jpeg&#34; alt=&#34;网页捕获_23-11-2022_23212_www.jianshu.com&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2先声明指针再初始化最好不要这样-_-&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2先声明指针再初始化最好不要这样-_-&#34;&gt;#&lt;/a&gt; 2. 先声明指针再初始化 (最好不要这样 - _ -)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在 &lt;code&gt;C&lt;/code&gt;  语言中，定义局部变量时如果未初始化，那么它的值将会是随机的；而全局变量 、静态变量初始值为  &lt;code&gt;0&lt;/code&gt;  ；所以如果你不想你的程序有炸掉的风险的话，请  &lt;mark&gt;声明指针并直接初始化&lt;/mark&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;四查看指针地址和指针的值&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#四查看指针地址和指针的值&#34;&gt;#&lt;/a&gt; 四。查看指针地址和指针的值&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;指针&lt;/code&gt; 的占位符则是用  &lt;code&gt;%p&lt;/code&gt;  或者  &lt;code&gt;%x&lt;/code&gt;  (x 并不是 x) 表示，具体使用参考下面例子：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202211232341430.jpeg&#34; alt=&#34;网页捕获_23-11-2022_232258_www.jianshu.com&#34;&gt;&lt;/p&gt;
&lt;p&gt;在如上例子中：声明了一个整形变量  &lt;code&gt;iValue&lt;/code&gt;  ，并使用指针  &lt;code&gt;pValue&lt;/code&gt;  执行整形变量  &lt;code&gt;iValue&lt;/code&gt;  ，根据输出的信息可以得到结论：&lt;strong&gt;&lt;u&gt;两者的内存地址都一样&lt;/u&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于整形变量  &lt;code&gt;iValue&lt;/code&gt;  指针变量  &lt;code&gt;pValue&lt;/code&gt;  内存地址一样，整形变量  &lt;code&gt;iValue&lt;/code&gt;  的值发生变化后指针  &lt;code&gt;pValue&lt;/code&gt;  也会跟着一起变化 (所以好像会互相影响呢)，指针  &lt;code&gt;pValue&lt;/code&gt;  的值发生变化后整形变量  &lt;code&gt;iValue&lt;/code&gt;  的值也会跟着一起变化，两者本来就是 ==&lt;u&gt;同一个&lt;/u&gt;==，&lt;/strong&gt; 就好比既可以通过&lt;mark&gt;名字&lt;/mark&gt;来找到你，也可以通过&lt;mark&gt;身份证号码&lt;/mark&gt;来找到你。&lt;/p&gt;
&lt;h2 id=&#34;五null-指针-空指针&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#五null-指针-空指针&#34;&gt;#&lt;/a&gt; 五.NULL 指针 – 空指针&lt;/h2&gt;
&lt;p&gt;在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个  &lt;code&gt;NULL&lt;/code&gt;  值，赋为  &lt;code&gt;NULL&lt;/code&gt;  值的指针被称为 == &lt;code&gt;空指针&lt;/code&gt;  ==。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;code&gt;NULL&lt;/code&gt;  指针是一个定义在标准库中的值为零的常量&lt;/strong&gt;。请看下面的程序：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202211232348261.jpeg&#34; alt=&#34;网页捕获_23-11-2022_232357_www.jianshu.com&#34;&gt;&lt;/p&gt;
&lt;p&gt;在大多数的操作系统上，程序是不允许用户访问&lt;u&gt;地址为 0&lt;/u&gt; 的内存，&lt;u&gt;因为该内存是操作系统保留的&lt;/u&gt;。然而，内存地址 0 有&lt;mark&gt;特别重要的意义&lt;/mark&gt;，它表明该指针&lt;u&gt;不指向一个可访问的内存位置&lt;/u&gt;。但按照惯例，如果指针包含 &lt;strong&gt;空值&lt;/strong&gt;（零值），&lt;u&gt;则假定它不指向任何东西&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;如需检查一个空指针，您可以使用 &lt;code&gt;if&lt;/code&gt;  语句，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202211232352132.jpeg&#34; alt=&#34;网页捕获_23-11-2022_232423_www.jianshu.com&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;六重点总结&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#六重点总结&#34;&gt;#&lt;/a&gt; 六。重点总结&lt;/h2&gt;
&lt;p&gt;1. 指针作为一个变量，拥有自己的地址，占位符使用 &lt;code&gt;%p&lt;/code&gt;  或者 &lt;code&gt; %x&lt;/code&gt; ；&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202211232354862.jpeg&#34; alt=&#34;网页捕获_23-11-2022_232446_www.jianshu.com&#34;&gt;&lt;/p&gt;
&lt;p&gt;2. 取指针的值需要在指针变量前面加上  &lt;code&gt;*&lt;/code&gt;  ，否则是取指针的地址；&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202211232359851.jpeg&#34; alt=&#34;网页捕获_23-11-2022_232510_www.jianshu.com&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;` 部分图片来自网络&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/10/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3python%E8%AF%AD%E8%A8%80[%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B]/</guid>
            <title>深入理解python语言[基本数据类型]</title>
            <link>http://example.com/2022/10/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3python%E8%AF%AD%E8%A8%80[%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B]/</link>
            <category>python</category>
            <pubDate>Sun, 30 Oct 2022 16:33:19 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;深入理解python语言基本数据类型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#深入理解python语言基本数据类型&#34;&gt;#&lt;/a&gt; 深入理解 python 语言 [基本数据类型]&lt;/h1&gt;
&lt;h2 id=&#34;1整数类型与数学中整数的概念一致&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1整数类型与数学中整数的概念一致&#34;&gt;#&lt;/a&gt; 1. 整数类型（与数学中整数的概念一致）&lt;/h2&gt;
&lt;p&gt;—  可正可负，&lt;strong&gt;没有取值范围的限制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;—  pow (x,y) : 计算 x&lt;sup&gt;y&lt;/sup&gt;, 不限制计算的大小【C 语言也有 pow ()】&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; pow(2,100)&lt;/p&gt;
&lt;p&gt;//python 整数提供&lt;u&gt;四种&lt;/u&gt;进制表现形式：十进制，二进制，八进制，十六进制 //&lt;/p&gt;
&lt;h2 id=&#34;2浮点数类型与数学中实数的概念一致&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2浮点数类型与数学中实数的概念一致&#34;&gt;#&lt;/a&gt; 2. 浮点数类型（与数学中实数的概念一致）&lt;/h2&gt;
&lt;p&gt;—  带有小数点及小数的数字&lt;/p&gt;
&lt;p&gt;—  浮点数取值范围和小数精度存在限制，但常规计算可以忽略&lt;/p&gt;
&lt;p&gt;—  取值范围数量级约 - 10&lt;sup&gt;308&lt;/sup&gt; 至 10&lt;sup&gt;308&lt;/sup&gt; (比 C 语言大多了), 精度数量级 10&lt;sup&gt;-16&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;—  &lt;strong&gt;浮点数间运算和比较用 &lt;code&gt;round()&lt;/code&gt;  函数辅助&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;// 浮点数间的运算存在不确定尾数（我才知道这在很多编程语言中都存在 —__—）//&lt;/p&gt;
&lt;p&gt;例题：&amp;gt;&amp;gt;&amp;gt; 0.1+0.2 == 0.3&lt;/p&gt;
&lt;p&gt;False (就是会这样)&lt;/p&gt;
&lt;p&gt;可以使用 round 函数&lt;/p&gt;
&lt;p&gt;—   round (x,d) : 对 x 四舍五入，d 是小数的解取位数（本题 d=1，四舍五入到 0.1，便可以成立）&lt;/p&gt;
&lt;p&gt;&lt;u&gt;&lt;strong&gt; &lt;code&gt;浮点数可以采用科学计数法表示&lt;/code&gt; &lt;/strong&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;—   使用字母 e 或者 E 作为幂的符号，以 10 为基数，格式如下：&lt;/p&gt;
&lt;p&gt;&lt;a&gt;e&lt;b&gt;      表示 a*10&lt;sup&gt;b&lt;/sup&gt;&lt;/b&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;—   例如：4.3e-3==0.0043       9.6E5==960000.0&lt;/p&gt;
&lt;h2 id=&#34;3复数类型与数学中的复数概念一致&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#3复数类型与数学中的复数概念一致&#34;&gt;#&lt;/a&gt; 3. 复数类型 (与数学中的复数概念一致)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;mark&gt;众多编程语言中，只有 python 提供复数类型&lt;/mark&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;—  定义     &lt;strong&gt;&lt;mark&gt;j&lt;/mark&gt;&lt;/strong&gt;=(-1)&lt;sup&gt;0.5&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;—   a+b==&lt;strong&gt;j&lt;/strong&gt;== 被称为复数，其中，a 为实部，b 为虚部&lt;/p&gt;
&lt;p&gt;例题：&lt;/p&gt;
&lt;p&gt;z = 1.23e - 4 + 5.6e + 89&lt;strong&gt;j&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;—  实部是什么？   z.real 获得实部&lt;/p&gt;
&lt;p&gt;—  虚部是什么？   z.imag 获得虚部&lt;/p&gt;
&lt;p&gt;// 在常规的计算机编程中很少使用 //&lt;/p&gt;
&lt;h2 id=&#34;4数值运算操作符&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#4数值运算操作符&#34;&gt;#&lt;/a&gt; 4. 数值运算操作符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;x+y   [加，x 与 y 的和]&lt;/li&gt;
&lt;li&gt;x-y    [减，x 与 y 的差]&lt;/li&gt;
&lt;li&gt;x*y   [乘，x 与 y 的积]&lt;/li&gt;
&lt;li&gt;x/y    [除，x 与 y 的商   10/3=3.3333333333333333335]&lt;/li&gt;
&lt;li&gt;x//y   [整数除，x 与 y 的整数商    10//3=3]&lt;/li&gt;
&lt;li&gt;+x      [x 本身]&lt;/li&gt;
&lt;li&gt;-y       [y 的负值]&lt;/li&gt;
&lt;li&gt;x% y   [余数，模运算  10%3 的结果是 1]&lt;/li&gt;
&lt;li&gt;x**y  [幂运算，x 的 y 次幂，x&lt;sup&gt;y&lt;/sup&gt;|| 当 y 是小数时，开方运算  10**0.5 的结果是 10&lt;sup&gt;0.5&lt;/sup&gt;]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;u&gt;&lt;strong&gt; &lt;code&gt;二元操作符对应的增强赋值操作符&lt;/code&gt; &lt;/strong&gt;&lt;/u&gt;(类似于 C 语言的赋值操作)&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202210302100493.jpeg&#34; alt=&#34;网页捕获_30-10-2022_2102_www.icourse163.org&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;u&gt; &lt;code&gt;不同数字类型间可以进行混合运算，生成结果“最宽”的类型&lt;/code&gt; &lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;— 三种类型存在一种逐渐 “扩展” 或 “变宽” 的关系：&lt;/p&gt;
&lt;p&gt;整数   -&amp;gt;   浮点数   -&amp;gt;   复数&lt;/p&gt;
&lt;p&gt;— 例如：123 + 4.0 =127.0 (整数 + 浮点数 = 浮点数)&lt;/p&gt;
&lt;h2 id=&#34;5数值运算函数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#5数值运算函数&#34;&gt;#&lt;/a&gt; 5. 数值运算函数&lt;/h2&gt;
&lt;p&gt;&lt;u&gt;python 内置一些函数&lt;/u&gt;(不得不说，python 跟 C 比起来真的是强了十倍甚至是九倍)@_@-!&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202210302114974.jpeg&#34; alt=&#34;网页捕获_30-10-2022_211426_www.icourse163.org&#34;&gt;&lt;/p&gt;
&lt;p&gt;=======================================================================================================================================================================================================================================================================================================================================================================================================&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202210302119261.jpeg&#34; alt=&#34;网页捕获_30-10-2022_211846_www.icourse163.org&#34;&gt;&lt;/p&gt;
&lt;p&gt;=======================================================================================================================================================================================================================================================================================================================================================================================================&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202210302121832.jpeg&#34; alt=&#34;网页捕获_30-10-2022_212114_www.icourse163.org&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/10/12/csapp%E7%AC%ACll%E7%AB%A0/</guid>
            <title>csapp第二章</title>
            <link>http://example.com/2022/10/12/csapp%E7%AC%ACll%E7%AB%A0/</link>
            <category>csapp</category>
            <pubDate>Wed, 12 Oct 2022 19:07:35 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;csapp第二章可能没什么帮助就随便看看吧&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#csapp第二章可能没什么帮助就随便看看吧&#34;&gt;#&lt;/a&gt; csapp 第二章（可能没什么帮助，就随便看看吧）&lt;/h1&gt;
&lt;p&gt;（现代计算机以二进制存储信息。相较于十进制，它能更好的适配计算机，能够更可靠的进行信息的表示、存储传输；用不同的位组合来表示元素；三种重要的数字编码：&lt;u&gt;无符号编码&lt;/u&gt;，&lt;u&gt;二进制补码&lt;/u&gt;，&lt;u&gt;浮点数编码&lt;/u&gt;；）&lt;/p&gt;
&lt;h1 id=&#34;21信息存储&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#21信息存储&#34;&gt;#&lt;/a&gt; 2.1 信息存储&lt;/h1&gt;
&lt;p&gt;1. 字节（byte）是&lt;strong&gt; 8 位&lt;/strong&gt;的块，&lt;u&gt;作为最小的可寻址的存储器单位&lt;/u&gt;&amp;lt;而不是单独的位&amp;gt;.&lt;/p&gt;
&lt;p&gt;2. 存储器中每个字节由一个惟一的数字标识，这称之为他的&lt;u&gt;地址&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;3. 所有可能地址的集合，称为&lt;u&gt;虚拟地址空间&lt;/u&gt;。&amp;lt;像一个分好类别的仓库吧？&amp;gt;&lt;/p&gt;
&lt;p&gt;4. 编译和运行时，系统将存储空间划分为更可管理的单元，来存放不同程序对象（程序数据、指令和控制信息）。&amp;lt;分类存放，便于之后的管理与取用&amp;gt;&lt;/p&gt;
&lt;h2 id=&#34;211十六进制表示法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#211十六进制表示法&#34;&gt;#&lt;/a&gt; 2.1.1 十六进制表示法&lt;/h2&gt;
&lt;p&gt;因为二进制表示太冗长，而十进制与位模式的互相转化很麻烦，两种符号表示法都比较麻烦。所以采取 16 进制来书写位模式。编写机械级程序常常需要手工地进行十、二、十六之间的转换。&lt;u&gt;需要掌握进制之间的转化方法&lt;/u&gt;。&lt;/p&gt;
&lt;h2 id=&#34;212-字&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#212-字&#34;&gt;#&lt;/a&gt; 2.1.2 字&lt;/h2&gt;
&lt;p&gt;每台计算机都有一个字长（world size），指明整数和指针数据的标称大小（normal size）。&lt;strong&gt;字长 决定虚拟地址的最大大小&lt;/strong&gt;。&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNDAyNDc1L2FydGljbGUvZGV0YWlscy8xMjQ4MDk5MjE=&#34;&gt;字长是什么&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;213-数据大小&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#213-数据大小&#34;&gt;#&lt;/a&gt; 2.1.3 数据大小&lt;/h2&gt;
&lt;p&gt;计算机和编译器用不同方式来编码数字，如不同长度的整数和浮点数，从而支持多种数字格式。（程序员应该提高他们编写程序的可移植性，就是说，使得程序对不同数据类型的准确大小不敏感）&amp;lt;就是可以在其他设备，其他系统上运行？&amp;gt;&lt;/p&gt;
&lt;h2 id=&#34;214寻址和字节顺序&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#214寻址和字节顺序&#34;&gt;#&lt;/a&gt; 2.14 寻址和字节顺序&lt;/h2&gt;
&lt;p&gt;对于跨越多字节的程序对象，要建立两个规则：1. 对象地址是什么；2. 在存储器中如何对这些字节排序。几乎所有机器，&lt;u&gt;多字节对象都被存储为连续的字节序列，对象的地址为&lt;strong&gt;所使用字节序列中的最小地址&lt;/strong&gt;。&lt;/u&gt;（越小越精确，要找到对象的精确地址？）&lt;/p&gt;
&lt;h2 id=&#34;215-表示字符串&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#215-表示字符串&#34;&gt;#&lt;/a&gt; 2.15 表示字符串&lt;/h2&gt;
&lt;p&gt;字符串被编码为一个&lt;strong&gt;以 null（其值）字符结尾&lt;/strong&gt;的字符数组。每个字符由标准码表示，常用 ASCII 字符码。（&lt;u&gt;文本数据比二进制数据具有更强的平台独立性&lt;/u&gt;）&amp;lt;不是特别理解・-・&amp;gt;&lt;/p&gt;
&lt;h2 id=&#34;216-表示代码&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#216-表示代码&#34;&gt;#&lt;/a&gt; 2.1.6 表示代码&lt;/h2&gt;
&lt;p&gt;多数情况下，&lt;u&gt;不同机器类型使用不同且不兼容的指令和编码方式。&lt;/u&gt;二进制代码很少能在不同机器和操作系统组合之间移植。&lt;/p&gt;
&lt;h2 id=&#34;217-布尔代数和环&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#217-布尔代数和环&#34;&gt;#&lt;/a&gt; 2.1.7 布尔代数和环&lt;/h2&gt;
&lt;p&gt;因为二进制是计算机编码、存储和操作信息的核心，所以围绕数值 0 和 1 已经演化出了丰富的数学知识体系。（I compeletly don’t understand what it wants telling me）&lt;/p&gt;
&lt;h2 id=&#34;218-c中的位级运算&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#218-c中的位级运算&#34;&gt;#&lt;/a&gt; 2.1.8  C 中的位级运算&lt;/h2&gt;
&lt;p&gt;C 的一个很有用的特性就是它是支持按位布尔运算，在布尔运算中使用的那些符号就是在 C 中使用的。（&lt;u&gt;确定一个位级表达式的结果的最好的方法就是将十六进制参数扩展成他们的二进制表示，执行二进制运算，然后再转换为十六进制。&amp;lt;/u）&lt;/p&gt;
&lt;h2 id=&#34;219-c中的逻辑运算&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#219-c中的逻辑运算&#34;&gt;#&lt;/a&gt; 2.1.9   C 中的逻辑运算&lt;/h2&gt;
&lt;p 逻辑运算认为所有非零参数都表示true，而参数零表示false=&#34;&#34;&gt;C 中提供了一系列的逻辑运算符，但逻辑运算容易与位级运算相混淆，而他们的功能又是完全不同的。&lt;/p&gt;
&lt;h2 id=&#34;2110-c中的移位运算&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2110-c中的移位运算&#34;&gt;#&lt;/a&gt; 2.1.10  C 中的移位运算&lt;/h2&gt;
&lt;p&gt;C 提供了一系列的移位运算，有向左或向右移位模式。（移动后要用 0 进行补位）&lt;/p&gt;
&lt;h1 id=&#34;22-整数表示&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#22-整数表示&#34;&gt;#&lt;/a&gt; 2.2 整数表示&lt;/h1&gt;
&lt;h2 id=&#34;221整型数据类型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#221整型数据类型&#34;&gt;#&lt;/a&gt; 2.2.1 整型数据类型&lt;/h2&gt;
&lt;p&gt;C 支持多种整型数据类型 —— 表示有限范围的整数。如 char、short、int、、long。C 标准定义了每种数据类型必须能够表示的最小值范围。具体而言，数据类型的取值会有差异。&lt;/p&gt;
&lt;h2 id=&#34;222无符号和二进制补码编码&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#222无符号和二进制补码编码&#34;&gt;#&lt;/a&gt; 2.2.2 无符号和二进制补码编码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;二进制的补码范围是不对称的，容易产生错误。&lt;/li&gt;
&lt;li&gt;最大无符号值刚好比二进制补码的最大值的两倍大一（1）点。&lt;/li&gt;
&lt;li&gt;尽管 C 的标准没有要求用二进制补码形式来表示有符号整数，但几乎所有机器都是这么的。&lt;/li&gt;
&lt;li&gt;对有符号数，其最高有效位也称为符号位（sign bit），0 为正，1 为负。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;223有符号数和无符号数之间的转换&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#223有符号数和无符号数之间的转换&#34;&gt;#&lt;/a&gt; 2.2.3 有符号数和无符号数之间的转换&lt;/h2&gt;
&lt;p&gt;依托两者之间的映射关系进行转换，具体方法如有需要：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aGlkYW8uYmFpZHUuY29tL3F1ZXN0aW9uLzUxMjk3MjAwLmh0bWw=&#34;&gt;有符号数如何与无符号数转换&lt;/span&gt;                    &amp;lt;用 ctrl + 点击&amp;gt;&lt;/p&gt;
&lt;h2 id=&#34;224-c中的有符号与无符号数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#224-c中的有符号与无符号数&#34;&gt;#&lt;/a&gt; 2.2.4 C 中的有符号与无符号数&lt;/h2&gt;
&lt;p&gt;C 支持所有整数数据类型的有符号与无符号运算。尽管 C 标准没有指定某种有符号数的表示，但几乎所有机器都使用二进制补码。通常，大多数数字都是默认有符号的。（另外，当一种类型的表达式被赋值给另一种类型的变量时，转换是隐式发生的）&lt;/p&gt;
&lt;p&gt;当执行一个运算时，如果它的一个运算数是有符号而另一个是无符号，那么 C 将有符号参数类型转换为无符号数，并假设两数非负，并执行。（于一些情况下会导致运算错误）&lt;/p&gt;
&lt;h2 id=&#34;225扩展一个数字的位表示&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#225扩展一个数字的位表示&#34;&gt;#&lt;/a&gt; 2.2.5 扩展一个数字的位表示&lt;/h2&gt;
&lt;p&gt;一个常见的运算是在不同字长的整数之间转换，同时保持数值不变。而当目标类型太小了，则转换可能失效，但从较小到较大，应该总可能的。（*&lt;em&gt; 将一个无符号数转换为一个更大的数据类型，只要简单的在表示的开头添加 0，这种运算被称为零扩展（zero extension）；要将一个二进制补码数字转换俄日一个更大的数据类型，规则是执行一个符号扩展（sign extension），在表示中添加最高有效位的值）。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;从一个数据大小到另一个数据大小，以及&lt;u&gt;无符号和有符号数字之间的转换的相对顺序&lt;/u&gt;能够影响一个程序的行为。&lt;/p&gt;
&lt;h2 id=&#34;226-截断数字&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#226-截断数字&#34;&gt;#&lt;/a&gt; 2.2.6 截断数字&lt;/h2&gt;
&lt;p&gt;详见：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpcGFucGFuOTAwNzIxL2FydGljbGUvZGV0YWlscy8xMjA4MDQ0MTc=&#34;&gt;截断数字&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;227有符号数和无符号数的建议&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#227有符号数和无符号数的建议&#34;&gt;#&lt;/a&gt; 2.2.7 有符号数和无符号数的建议&lt;/h2&gt;
&lt;p&gt;1. 尽量不要在你的代码中使用无符号数，以免增加不必需要的复杂性。&lt;/p&gt;
&lt;p&gt;2. 尽量使用像 int 那样的有符号类型，这样在涉及升级混合类型的复杂细节时，不必担心边界情况。&lt;/p&gt;
&lt;p&gt;3. 只有在使用位段和二进制掩码时，才可以用无符号数。应该在表达式中使用强制类型转换，使操作数均为有符号或无符号数，这样就不必由编译器来选择结果的类型。&lt;/p&gt;
&lt;h1 id=&#34;23-整数运算&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#23-整数运算&#34;&gt;#&lt;/a&gt; 2.3 整数运算&lt;/h1&gt;
&lt;h2 id=&#34;231无符号加法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#231无符号加法&#34;&gt;#&lt;/a&gt; 2.3.1 无符号加法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;要想完整地表示运算结果，不能对字长做任何限制。&lt;/li&gt;
&lt;li&gt;常见的编程语言支持固定精度的运算，因此 “加法” 和 “乘法” 这样的运算不同于它们在整数上的相应运算。&lt;/li&gt;
&lt;li&gt;无符号运算可视作一种形式的模运算。&lt;/li&gt;
&lt;li&gt;&lt;u&gt;&lt;strong&gt;算术运算溢出&lt;/strong&gt;&lt;/u&gt;，是指完整的整数结果不能放到数据类型的字长限制中。（&lt;u&gt;执行 C 程序时，不会将溢出作为错误而发出信号&lt;/u&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;232二进制补码加法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#232二进制补码加法&#34;&gt;#&lt;/a&gt; 2.3.2 二进制补码加法&lt;/h2&gt;
&lt;p&gt;与无符号加法有相似之处，详见导引。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1p3bl8yMjMvYXJ0aWNsZS9kZXRhaWxzLzEyMDE2ODc5OA==&#34;&gt;1 号导引&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuemhhbmdzaGlsb25nLmNuL3dvcmsvMjYwNTk1Lmh0bWw=&#34;&gt;2 号导引&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;233-二进制补码的非&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#233-二进制补码的非&#34;&gt;#&lt;/a&gt; 2.3.3 二进制补码的非&lt;/h2&gt;
&lt;p&gt;一种有名的用来执行位级二进制补码的非（negation）的 技术是对每个位取反（或取补），然后将结果加一。（以后还请回看 csapp   &amp;gt;_&amp;lt;）&lt;/p&gt;
&lt;h2 id=&#34;234无符号乘法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#234无符号乘法&#34;&gt;#&lt;/a&gt; 2.3.4 无符号乘法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;0*0=0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;0*1=0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1*0=0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1*1=1&lt;/p&gt;
&lt;p&gt;二进制乘法相似于十进制乘法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;235二进制补码乘法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#235二进制补码乘法&#34;&gt;#&lt;/a&gt; 2.3.5 二进制补码乘法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;补码 * 补码 = 补码（什么哦 *^*）&lt;/li&gt;
&lt;li&gt;1、无符号数 * 无符号数 = 无符号数&lt;br&gt;
 2、无符号数 * 有符号数 = 有符号数&lt;br&gt;
 3、有符号数 * 无符号数 = 有符号数&lt;br&gt;
 4、有符号数 * 有符号数 = 有符号数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;236与237-乘除2的幂&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#236与237-乘除2的幂&#34;&gt;#&lt;/a&gt; 2.3.6 与 2.3.7  乘除 2 的幂&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B1bXBpL2FydGljbGUvZGV0YWlscy8xMDQ0OTc1Mjk=&#34;&gt;计算 2 的幂的解方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ2RqZHNqaC9wLzUwMzc2NzMuaHRtbCM6fjp0ZXh0PSVFNSU5QyVBOCVFNSVBNCVBNyVFNSVBNCU5QSVFNiU5NSVCMCVFNyU5QSU4NCVFNiU5QyVCQSVFNSU5OSVBOCVFNCVCOCVBRCVFRiVCQyU4QyVFOSU5OSVBNCVFNiVCMyU5NSVFOCVBNiU4MSVFNiVBRiU5NCVFNCVCOSU5OCVFNiVCMyU5NSVFOCVCRiU5OCVFNiU5QyU4OSVFNSU4QSVBMCVFNiVCMyU5NSVFOCVCRiU5OSVFNCVCQSU5Qg==&#34;&gt;具体解释 1&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQ0NjI1Mi9hcnRpY2xlL2RldGFpbHMvMTA5MzgwMDEx&#34;&gt;通过位运算来进行 2 的幂运算&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;24浮点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#24浮点&#34;&gt;#&lt;/a&gt; 2.4 浮点&lt;/h1&gt;
&lt;p&gt;用于精确的计算，提高运算精度。&lt;/p&gt;
&lt;h2 id=&#34;241-二进制小数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#241-二进制小数&#34;&gt;#&lt;/a&gt; 2.4.1  二进制小数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;与十进制类似，用科学计数法表示（以 2 作指数底数）。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分为整数与小数两个部分，常常要在运算中分离处理&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;二进制小数末尾添上 0 或去掉 0，小数的大小也不变，但是意义不一样。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;正二进制整数或小数的开头添上 0 或去掉 0，数的大小不变。负二进制整数或小数的开头添上 1 或去掉 1，数的大小也不变。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;242-ieee浮点表示&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#242-ieee浮点表示&#34;&gt;#&lt;/a&gt; 2.4.2  IEEE 浮点表示&lt;/h2&gt;
&lt;p&gt;IEEE 标准 754 规定了三种浮点数格式：单精度、双精度、扩展精度。前两者正好对应 C 语言里头的 float、double 或者 FORTRAN 里头的 real、double 精度类型。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk3OTMwNC9hcnRpY2xlL2RldGFpbHMvMTA4MDQ0NzU0&#34;&gt;详见&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;243-数值示例&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#243-数值示例&#34;&gt;#&lt;/a&gt; 2.4.3 数值示例&lt;/h2&gt;
&lt;p&gt;来日方长：详见 csapp  p87&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://cdn.jsdelivr.net/gh/TCworkor/images/img/202210171328815.png&#34; alt=&#34;截图20221002221650&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;244舍入&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#244舍入&#34;&gt;#&lt;/a&gt; 2.4.4 舍入&lt;/h2&gt;
&lt;p&gt;因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似表示实数运算。&lt;/p&gt;
&lt;p&gt;舍入运算，可以找到最接近的匹配值。（需要定义舍入方向）&lt;/p&gt;
&lt;p&gt;舍入会存在偏差，（向偶数舍入可以避免偏差）&lt;/p&gt;
&lt;h2 id=&#34;245-浮点运算&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#245-浮点运算&#34;&gt;#&lt;/a&gt; 2.4.5 浮点运算&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;浮点数的加减运算分为 5 个步骤：对阶、尾数相加、尾数规格化、尾数舍入处理、溢出判断处理。&lt;/p&gt;
&lt;h5 id=&#34;1-对阶所谓对阶就是让两个操作数阶数相同以便进行加减-实现的方式是对较小数的尾数进行右移操作-对阶的原则是向高阶看齐&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-对阶所谓对阶就是让两个操作数阶数相同以便进行加减-实现的方式是对较小数的尾数进行右移操作-对阶的原则是向高阶看齐&#34;&gt;#&lt;/a&gt; 1. 对阶：所谓对阶，就是让两个操作数阶数相同，以便进行加减。实现的方式是对较小数的尾数进行右移操作。对阶的原则是向高阶看齐。&lt;/h5&gt;
&lt;h5 id=&#34;2-尾数加减将两个操作数的尾数相加减-在ieee754标准中对于规格化数来说在小数点前有一位隐藏位1在加减过程中需要把它还原到尾数中-尾数加减的实质是原码的加减&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-尾数加减将两个操作数的尾数相加减-在ieee754标准中对于规格化数来说在小数点前有一位隐藏位1在加减过程中需要把它还原到尾数中-尾数加减的实质是原码的加减&#34;&gt;#&lt;/a&gt; 2. 尾数加减：将两个操作数的尾数相加减。在 IEEE754 标准中，对于规格化数来说在小数点前有一位隐藏位 1，在加减过程中需要把它还原到尾数中。尾数加减的实质是原码的加减，&lt;/h5&gt;
&lt;h5 id=&#34;3尾数规格化加减完成的尾数形式未必满足ieee754对于尾数的要求即保留23位小数点在第一个1之后-需要对尾数进行左规和右规下面介绍一下左规和右规-左规将尾数向左移用于清除第一个1前面出现的0-左规伴随着阶码减少在左规过程中要检测阶码是否发生下溢即阶码达到最小值0000-0000-右规将尾数向右移用于两数相加后出现向高位进位的情况-因为两数相加最多进一位所以右规最多一位-右规伴随着阶码的增加在右规过程中要检测阶码是否发生上溢即阶码达到最大值1111-1111&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#3尾数规格化加减完成的尾数形式未必满足ieee754对于尾数的要求即保留23位小数点在第一个1之后-需要对尾数进行左规和右规下面介绍一下左规和右规-左规将尾数向左移用于清除第一个1前面出现的0-左规伴随着阶码减少在左规过程中要检测阶码是否发生下溢即阶码达到最小值0000-0000-右规将尾数向右移用于两数相加后出现向高位进位的情况-因为两数相加最多进一位所以右规最多一位-右规伴随着阶码的增加在右规过程中要检测阶码是否发生上溢即阶码达到最大值1111-1111&#34;&gt;#&lt;/a&gt; 3. 尾数规格化：加减完成的尾数形式未必满足 IEEE754 对于尾数的要求，即保留 23 位，小数点在第一个 1 之后。需要对尾数进行左规和右规，下面介绍一下左规和右规。左规：将尾数向左移，用于清除第一个 1 前面出现的 0。左规伴随着阶码减少，在左规过程中要检测阶码是否发生下溢，即阶码达到最小值（0000 0000）。右规：将尾数向右移，用于两数相加后出现向高位进位的情况。因为两数相加最多进一位，所以右规最多一位。右规伴随着阶码的增加，在右规过程中要检测阶码是否发生上溢，即阶码达到最大值（1111 1111）。&lt;/h5&gt;
&lt;h5 id=&#34;&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#&#34;&gt;#&lt;/a&gt; &lt;/h5&gt;
&lt;h5 id=&#34;5-溢出判断-在浮点数中是以阶码的溢出与否来作为评判标准的-单精度溢出分为上溢指数大于等于127和下溢指数小于等于-126&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#5-溢出判断-在浮点数中是以阶码的溢出与否来作为评判标准的-单精度溢出分为上溢指数大于等于127和下溢指数小于等于-126&#34;&gt;#&lt;/a&gt; 5. 溢出判断：  在浮点数中是以阶码的溢出与否来作为评判标准的。单精度溢出分为上溢（指数大于等于 127）和下溢（指数小于等于 - 126)。&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详见：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dsc19udWFhL2FydGljbGUvZGV0YWlscy8xMDU0MDEzNzI=&#34;&gt;详见&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&#34;25-小结&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#25-小结&#34;&gt;#&lt;/a&gt; 2.5 小结&lt;/h1&gt;
&lt;p&gt;虽然有很多不懂，但是就当作练习使用 typora 吧。以后回来看这些笔记怎么说也有帮助吧。（±+）&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/10/12/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
            <title>开始使用Linux操作系统</title>
            <link>http://example.com/2022/10/12/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
            <category>Linux</category>
            <pubDate>Wed, 12 Oct 2022 19:07:29 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;开始使用linux操作系统&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#开始使用linux操作系统&#34;&gt;#&lt;/a&gt; 开始使用 Linux 操作系统&lt;/h1&gt;
&lt;h2 id=&#34;2-1linux-目录结构与访问路径&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-1linux-目录结构与访问路径&#34;&gt;#&lt;/a&gt; 2-1；Linux 目录结构与访问路径&lt;/h2&gt;
&lt;h3 id=&#34;目录的基本概念&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#目录的基本概念&#34;&gt;#&lt;/a&gt; 目录的基本概念&lt;/h3&gt;
&lt;p&gt;目录是描述文件夹的专有名词。&lt;/p&gt;
&lt;p&gt;在计算机代码中，&lt;u&gt;文件夹形式与书本目录相同&lt;/u&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;书本目录记录所有书的章节名和页码。&lt;/li&gt;
&lt;li&gt;计算机目录记录其中包含的文件和对应的访问地址。&lt;/li&gt;
&lt;li&gt;相对于普通文件，目录也称为目录文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;linux文件系统是树形结构&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#linux文件系统是树形结构&#34;&gt;#&lt;/a&gt; Linux 文件系统是树形结构&lt;/h3&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;层次结构鲜明&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;易于扩展分支&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分支隔离互不依赖&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Windows 系统每个盘符作为文件根节点（C 盘。D 盘）&lt;/p&gt;
&lt;p&gt;Linux 系统采用单根结构，整个文件系统只有一个根。&lt;/p&gt;
&lt;h3 id=&#34;linux的根目录下有众多的二级目录如&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#linux的根目录下有众多的二级目录如&#34;&gt;#&lt;/a&gt; Linux 的根目录（/）下有众多的二级目录，如&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;（/boot，存放 Linux 启动所需的内核文件和镜像文件）&lt;/li&gt;
&lt;li&gt;(/bin, 存放最常用的命令)&lt;/li&gt;
&lt;li&gt;（/dev，存放 Linux 的外部设备，且在 Linux 中访问设备的方式和访问文件相同）&lt;/li&gt;
&lt;li&gt;（/etc，存放所有系统管理所需要的配置文件和子目录）&lt;/li&gt;
&lt;li&gt;（/home，用户的主目录，属于用户）&lt;/li&gt;
&lt;li&gt;（/root，此目录为系统管理员，也称作超级管理员 root 用户的主目录）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;访问路径&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#访问路径&#34;&gt;#&lt;/a&gt; 访问路径&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;绝对路径&lt;/strong&gt;（文件或目录相对于根目录的可访问路径）&lt;/p&gt;
&lt;p&gt;形式特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Windows：从盘符开始书写的路径。如：C：\Linux&lt;/li&gt;
&lt;li&gt;Linux：从根目录（/）开始书写的路径。如：/home&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优缺：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;具有&lt;u&gt;唯一性&lt;/u&gt;，但是只能在&lt;u&gt;特定的操作系统环境&lt;/u&gt;下才能准确定位目标路径。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;u&gt;不适合编写脚本&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;相对路径&lt;/strong&gt;（文件或目录相对于当前目录的可访问路径）&lt;/p&gt;
&lt;p&gt;形式特点：&lt;/p&gt;
&lt;p&gt;1. 不是从根目录（/）开始书写的路径。如：etc。&lt;/p&gt;
&lt;p&gt;2. 一般从当前目录开始书写&lt;/p&gt;
&lt;p&gt;tips：&lt;/p&gt;
&lt;p&gt;用 “.” 表示本级目录；用 “…” 表示上级目录。&lt;/p&gt;
&lt;p&gt;优缺：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一个参考体系内，&lt;u&gt;相对路径不变&lt;/u&gt;，适合编写脚本。&lt;/li&gt;
&lt;li&gt;计算较为&lt;strong&gt;复杂&lt;/strong&gt;，需要掌握文件系统的目录结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（归结而言一个是从根目录出发，一个是从其他的目录出发，但无论从什么地方出发，目的地是一样的，不过过程不同）&lt;/p&gt;
&lt;h2 id=&#34;2-2定位和切换目录&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-2定位和切换目录&#34;&gt;#&lt;/a&gt; 2-2 定位和切换目录&lt;/h2&gt;
&lt;h3 id=&#34;定位当前目录确定当前工作目录的绝对路径&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#定位当前目录确定当前工作目录的绝对路径&#34;&gt;#&lt;/a&gt; 定位当前目录（确定当前工作目录的绝对路径）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;命令&lt;/strong&gt;：pwd（打印当前工作目录）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;：当前所在工作目录的绝对路径&lt;/p&gt;
&lt;p&gt;（可用于相对路径的参考点）&lt;/p&gt;
&lt;h3 id=&#34;切换工作目录前往新的工作目录&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#切换工作目录前往新的工作目录&#34;&gt;#&lt;/a&gt; 切换工作目录（前往新的工作目录）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;命令&lt;/strong&gt;：cd（cd+【空格】+ 目标的绝对路径或相对路径）&lt;/p&gt;
&lt;p&gt;tips：&lt;/p&gt;
&lt;p&gt;{./}  表示当前目录&lt;/p&gt;
&lt;p&gt;{…/} 上一级目录&lt;/p&gt;
&lt;p&gt;单走 {cd} 直接切换至用户家目录&lt;/p&gt;
&lt;p&gt;{cd + 空格 + 横线} 切换到上一个工作目录（上一次工作的目录）&lt;/p&gt;
&lt;p&gt;{cd + 空格 + 波浪线} 切换到用户家目录&lt;/p&gt;
&lt;h2 id=&#34;2-3查看目录内容&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-3查看目录内容&#34;&gt;#&lt;/a&gt; 2-3 查看目录内容&lt;/h2&gt;
&lt;h3 id=&#34;ulinux命令基本范式u&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ulinux命令基本范式u&#34;&gt;#&lt;/a&gt; &lt;u&gt;&lt;strong&gt;Linux 命令基本范式&lt;/strong&gt;&lt;/u&gt;&lt;/h3&gt;
&lt;p&gt;含（命令关键词，命令选项，命令参数）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;范式&lt;/strong&gt;：&lt;strong&gt;命令关键字   选项     命令参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令关键字&lt;/strong&gt;：必不可少，指明要完成的具体操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选项&lt;/strong&gt;：可选，指定用什么方式来完成操作，一般有默认值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令参数&lt;/strong&gt;：可选，指明操作对象&lt;/p&gt;
&lt;h3 id=&#34;查看目录内容&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#查看目录内容&#34;&gt;#&lt;/a&gt; 查看目录内容&lt;/h3&gt;
&lt;p&gt;含（查看指定目标内容，按指定格式查看目录内容，按指定格式查看指定目录内容）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令&lt;/strong&gt;：ls  【选项】 【目录路径】（分别对应 ，命令关键字，选项，命令参数）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其中选项&lt;/strong&gt;：                                &lt;u&gt;注：（可以有多个选项内容，如：ls -l -a /  ； ls -al /）&lt;/u&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;l：长格式显示目录内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a：显示目录所有内容，包括隐藏文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无选项：仅显示非隐藏文件的名称&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;其中目录路径&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以是绝对路径，也可为相对路径&lt;/li&gt;
&lt;li&gt;无参数：默认显示当前目录下的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;tips：&lt;/p&gt;
&lt;p ls+空格+-l+空格+=&#34;&#34;&gt;{ll + 空格 +/}=&lt;/p&gt;
&lt;p&gt;ll    -d    /dev（查看 dev 目录的相关信息）&lt;/p&gt;
&lt;p&gt;ll     /dev（查看 dev 目录的内容）（注意空格）&lt;/p&gt;
&lt;p&gt;{ls + 空格 ±±+help}     查看命令的使用格式与方法。&lt;/p&gt;
&lt;p&gt;ll   查看当前目录内容&lt;/p&gt;
&lt;h2 id=&#34;2-4创建目录和文件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-4创建目录和文件&#34;&gt;#&lt;/a&gt; 2-4 创建目录和文件&lt;/h2&gt;
&lt;h3 id=&#34;u新建目录u含在指定位置新建目录在指定路径上新建所有目录同时新建多个目录&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#u新建目录u含在指定位置新建目录在指定路径上新建所有目录同时新建多个目录&#34;&gt;#&lt;/a&gt; &lt;u&gt;&lt;strong&gt;新建目录&lt;/strong&gt;&lt;/u&gt;，含 (在指定位置新建目录，在指定路径上新建所有目录，同时新建多个目录)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;命令&lt;/strong&gt;：mkdir  【选项】  【目录路径】&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其中目录路径&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以是绝对路径，也可以为相对路径&lt;/li&gt;
&lt;li&gt;可以是多个参数，表示一次性创建多个目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;其中选项&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;p：若指定的路径上有不存在目录，一并创建‘&lt;/li&gt;
&lt;li&gt;无选项：仅创建指定路径上最后一个目标目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;tips：&lt;/p&gt;
&lt;p&gt;mkdir   目录 1  ；表示新建目录 1&lt;/p&gt;
&lt;p&gt;mkdir    -p    目录 2 / 目录 3（此时会先在当前目录下创建目录 2，再在目录 2 下创建目录 3，，如果不使用 - p，则无法执行命令）&lt;/p&gt;
&lt;h3 id=&#34;新建文件含touch命令echo命令输出重定向&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#新建文件含touch命令echo命令输出重定向&#34;&gt;#&lt;/a&gt; 新建文件，含 (touch 命令，echo 命令输出重定向)&lt;/h3&gt;
&lt;p&gt;&lt;u&gt;法 1：touch  【文件路径】&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其中文件路径&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以是相对路径也可以是绝对路径&lt;/li&gt;
&lt;li&gt;可以是多个参数，表示一次性创建多个文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;u&gt;法 2：vi   【文件路径】&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其中文件路径&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以是绝对路径，也可以是相对路径&lt;/li&gt;
&lt;li&gt;可以是已经存在的文件（可以该编辑文件）&lt;/li&gt;
&lt;li&gt;也可以是还未创建的文件（新建并编辑该文件）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;u&gt;法 3：echo   内容信息     &amp;gt;|&amp;gt;&amp;gt;    【文件路径】&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出重定向符&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;{&amp;gt;}: 将命令的结果输出从显示器改到文件（覆盖）&lt;/li&gt;
&lt;li&gt;{&amp;gt;&amp;gt;}：将命令的结果输出从显示器改到文件（追加）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;其中文件路径&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以是绝对路径，也可以是相对路径‘&lt;/li&gt;
&lt;li&gt;可以是已经存在的文件（编辑文件）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;tips：&lt;/p&gt;
&lt;p&gt;touch     文件 1   | 创建一个文件&lt;/p&gt;
&lt;p&gt;touch     文件 2     | 文件 3    ；创建多个文件&lt;/p&gt;
&lt;p&gt;vi     文件 1    |（因为已经存在，所以编辑文件）（会进入 vi 编辑器中，i 键 进入插入模式  ，Esc 键退回 vi 命令模式，输入   ：  符  ，进入 vi 底行模式 ，输入 wq 保存文件）&lt;/p&gt;
&lt;p&gt;cat   文件 1  | 查看文件内容&lt;/p&gt;
&lt;p&gt;cat    文件 4  | 文件不存在，则先创建再编辑&lt;/p&gt;
&lt;p&gt;echo “这是文件 5”      &amp;gt;     文件 5&lt;/p&gt;
&lt;p&gt;echo “2002  3 2”   &amp;gt;&amp;gt;     文件 1（表示追加输入）&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
