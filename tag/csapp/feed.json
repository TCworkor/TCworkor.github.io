{
    "version": "https://jsonfeed.org/version/1",
    "title": "TCworker • All posts by \"csapp\" tag",
    "description": "time to work",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/12/csapp%E7%AC%AC%E4%BA%8C%E7%AB%A0/",
            "url": "http://example.com/2022/10/12/csapp%E7%AC%AC%E4%BA%8C%E7%AB%A0/",
            "title": "csapp第二章",
            "date_published": "2022-10-12T11:07:35.000Z",
            "content_html": "<h1 id=\"csapp第二章（可能没什么帮助，就随便看看吧）\"><a href=\"#csapp第二章（可能没什么帮助，就随便看看吧）\" class=\"headerlink\" title=\"csapp第二章（可能没什么帮助，就随便看看吧）\"></a>csapp第二章（可能没什么帮助，就随便看看吧）</h1><p>（现代计算机以二进制存储信息。相较于十进制，它能更好的适配计算机，能够更可靠的进行信息的表示、存储传输；用不同的位组合来表示元素；三种重要的数字编码：<u>无符号编码</u>，<u>二进制补码</u>，<u>浮点数编码</u>；）</p>\n<h1 id=\"2-1信息存储\"><a href=\"#2-1信息存储\" class=\"headerlink\" title=\"2.1信息存储\"></a>2.1信息存储</h1><p>1.字节（byte）是<strong>8位</strong>的块，<u>作为最小的可寻址的存储器单位</u>&lt;而不是单独的位&gt;.</p>\n<p>2.存储器中每个字节由一个惟一的数字标识，这称之为他的<u>地址</u>。</p>\n<p>3.所有可能地址的集合，称为<u>虚拟地址空间</u>。&lt;像一个分好类别的仓库吧？&gt;</p>\n<p>4.编译和运行时，系统将存储空间划分为更可管理的单元，来存放不同程序对象（程序数据、指令和控制信息）。&lt;分类存放，便于之后的管理与取用&gt;</p>\n<h2 id=\"2-1-1十六进制表示法\"><a href=\"#2-1-1十六进制表示法\" class=\"headerlink\" title=\"2.1.1十六进制表示法\"></a>2.1.1十六进制表示法</h2><p>因为二进制表示太冗长，而十进制与位模式的互相转化很麻烦，两种符号表示法都比较麻烦。所以采取16进制来书写位模式。编写机械级程序常常需要手工地进行十、二、十六之间的转换。<u>需要掌握进制之间的转化方法</u>。</p>\n<h2 id=\"2-1-2-字\"><a href=\"#2-1-2-字\" class=\"headerlink\" title=\"2.1.2 字\"></a>2.1.2 字</h2><p>每台计算机都有一个字长（world size），指明整数和指针数据的标称大小（normal size）。<strong>字长 决定虚拟地址的最大大小</strong>。<a href=\"https://blog.csdn.net/m0_51402475/article/details/124809921\">字长是什么</a></p>\n<h2 id=\"2-1-3-数据大小\"><a href=\"#2-1-3-数据大小\" class=\"headerlink\" title=\"2.1.3 数据大小\"></a>2.1.3 数据大小</h2><p>计算机和编译器用不同方式来编码数字，如不同长度的整数和浮点数，从而支持多种数字格式。（程序员应该提高他们编写程序的可移植性，就是说，使得程序对不同数据类型的准确大小不敏感）&lt;就是可以在其他设备，其他系统上运行?&gt;</p>\n<h2 id=\"2-14寻址和字节顺序\"><a href=\"#2-14寻址和字节顺序\" class=\"headerlink\" title=\"2.14寻址和字节顺序\"></a>2.14寻址和字节顺序</h2><p>对于跨越多字节的程序对象，要建立两个规则：1.对象地址是什么；2.在存储器中如何对这些字节排序。几乎所有机器，<u>多字节对象都被存储为连续的字节序列，对象的地址为<strong>所使用字节序列中的最小地址</strong>。</u>（越小越精确，要找到对象的精确地址？）</p>\n<h2 id=\"2-15-表示字符串\"><a href=\"#2-15-表示字符串\" class=\"headerlink\" title=\"2.15 表示字符串\"></a>2.15 表示字符串</h2><p>字符串被编码为一个<strong>以null（其值）字符结尾</strong>的字符数组。每个字符由标准码表示，常用ASCII字符码。（<u>文本数据比二进制数据具有更强的平台独立性</u>）&lt;不是特别理解·-·&gt;</p>\n<h2 id=\"2-1-6-表示代码\"><a href=\"#2-1-6-表示代码\" class=\"headerlink\" title=\"2.1.6 表示代码\"></a>2.1.6 表示代码</h2><p>多数情况下，<u>不同机器类型使用不同且不兼容的指令和编码方式。</u>二进制代码很少能在不同机器和操作系统组合之间移植。</p>\n<h2 id=\"2-1-7-布尔代数和环\"><a href=\"#2-1-7-布尔代数和环\" class=\"headerlink\" title=\"2.1.7 布尔代数和环\"></a>2.1.7 布尔代数和环</h2><p>因为二进制是计算机编码、存储和操作信息的核心，所以围绕数值0和1已经演化出了丰富的数学知识体系。（I compeletly don’t understand what it wants telling me）</p>\n<h2 id=\"2-1-8-C中的位级运算\"><a href=\"#2-1-8-C中的位级运算\" class=\"headerlink\" title=\"2.1.8  C中的位级运算\"></a>2.1.8  C中的位级运算</h2><p>C的一个很有用的特性就是它是支持按位布尔运算，在布尔运算中使用的那些符号就是在C中使用的。（<u>确定一个位级表达式的结果的最好的方法就是将十六进制参数扩展成他们的二进制表示，执行二进制运算，然后再转换为十六进制。&lt;&#x2F;u）</p>\n<h2 id=\"2-1-9-C中的逻辑运算\"><a href=\"#2-1-9-C中的逻辑运算\" class=\"headerlink\" title=\"2.1.9   C中的逻辑运算\"></a>2.1.9   C中的逻辑运算</h2><p>C中提供了一系列的逻辑运算符，但逻辑运算容易与位级运算相混淆，而他们的功能又是完全不同的。{逻辑运算认为所有非零参数都表示true，而参数零表示false}</p>\n<h2 id=\"2-1-10-C中的移位运算\"><a href=\"#2-1-10-C中的移位运算\" class=\"headerlink\" title=\"2.1.10  C中的移位运算\"></a>2.1.10  C中的移位运算</h2><p>C提供了一系列的移位运算，有向左或向右移位模式。（移动后要用0进行补位）</p>\n<h1 id=\"2-2-整数表示\"><a href=\"#2-2-整数表示\" class=\"headerlink\" title=\"2.2 整数表示\"></a>2.2 整数表示</h1><h2 id=\"2-2-1整型数据类型\"><a href=\"#2-2-1整型数据类型\" class=\"headerlink\" title=\"2.2.1整型数据类型\"></a>2.2.1整型数据类型</h2><p>C支持多种整型数据类型——表示有限范围的整数。如char、short、int、、long。C标准定义了每种数据类型必须能够表示的最小值范围。具体而言，数据类型的取值会有差异。</p>\n<h2 id=\"2-2-2无符号和二进制补码编码\"><a href=\"#2-2-2无符号和二进制补码编码\" class=\"headerlink\" title=\"2.2.2无符号和二进制补码编码\"></a>2.2.2无符号和二进制补码编码</h2><ul>\n<li>二进制的补码范围是不对称的，容易产生错误。</li>\n<li>最大无符号值刚好比二进制补码的最大值的两倍大一（1）点。</li>\n<li>尽管C的标准没有要求用二进制补码形式来表示有符号整数，但几乎所有机器都是这么的。</li>\n<li>对有符号数，其最高有效位也称为符号位（sign bit），0为正，1为负。</li>\n</ul>\n<h2 id=\"2-2-3有符号数和无符号数之间的转换\"><a href=\"#2-2-3有符号数和无符号数之间的转换\" class=\"headerlink\" title=\"2.2.3有符号数和无符号数之间的转换\"></a>2.2.3有符号数和无符号数之间的转换</h2><p>依托两者之间的映射关系进行转换，具体方法如有需要：<a href=\"https://zhidao.baidu.com/question/51297200.html\">有符号数如何与无符号数转换</a>                    &lt;用ctrl+点击&gt;</p>\n<h2 id=\"2-2-4-C中的有符号与无符号数\"><a href=\"#2-2-4-C中的有符号与无符号数\" class=\"headerlink\" title=\"2.2.4 C中的有符号与无符号数\"></a>2.2.4 C中的有符号与无符号数</h2><p>C支持所有整数数据类型的有符号与无符号运算。尽管C标准没有指定某种有符号数的表示，但几乎所有机器都使用二进制补码。通常，大多数数字都是默认有符号的。（另外，当一种类型的表达式被赋值给另一种类型的变量时，转换是隐式发生的）</p>\n<p>当执行一个运算时，如果它的一个运算数是有符号而另一个是无符号，那么C将有符号参数类型转换为无符号数，并假设两数非负，并执行。（于一些情况下会导致运算错误）</p>\n<h2 id=\"2-2-5扩展一个数字的位表示\"><a href=\"#2-2-5扩展一个数字的位表示\" class=\"headerlink\" title=\"2.2.5扩展一个数字的位表示\"></a>2.2.5扩展一个数字的位表示</h2><p>一个常见的运算是在不同字长的整数之间转换，同时保持数值不变。而当目标类型太小了，则转换可能失效，但从较小到较大，应该总可能的。（*<em>将一个无符号数转换为一个更大的数据类型，只要简单的在表示的开头添加0，这种运算被称为零扩展（zero extension）；要将一个二进制补码数字转换俄日一个更大的数据类型，规则是执行一个符号扩展（sign extension），在表示中添加最高有效位的值）。</em></p>\n<p>从一个数据大小到另一个数据大小，以及<u>无符号和有符号数字之间的转换的相对顺序</u>能够影响一个程序的行为。</p>\n<h2 id=\"2-2-6-截断数字\"><a href=\"#2-2-6-截断数字\" class=\"headerlink\" title=\"2.2.6 截断数字\"></a>2.2.6 截断数字</h2><p>详见：<a href=\"https://blog.csdn.net/lipanpan900721/article/details/120804417\">截断数字</a></p>\n<h2 id=\"2-2-7有符号数和无符号数的建议\"><a href=\"#2-2-7有符号数和无符号数的建议\" class=\"headerlink\" title=\"2.2.7有符号数和无符号数的建议\"></a>2.2.7有符号数和无符号数的建议</h2><p>1.尽量不要在你的代码中使用无符号数，以免增加不必需要的复杂性。</p>\n<p>2.尽量使用像int那样的有符号类型，这样在涉及升级混合类型的复杂细节时，不必担心边界情况。</p>\n<p>3.只有在使用位段和二进制掩码时，才可以用无符号数。应该在表达式中使用强制类型转换，使操作数均为有符号或无符号数，这样就不必由编译器来选择结果的类型。</p>\n<h1 id=\"2-3-整数运算\"><a href=\"#2-3-整数运算\" class=\"headerlink\" title=\"2.3 整数运算\"></a>2.3 整数运算</h1><h2 id=\"2-3-1无符号加法\"><a href=\"#2-3-1无符号加法\" class=\"headerlink\" title=\"2.3.1无符号加法\"></a>2.3.1无符号加法</h2><ul>\n<li>要想完整地表示运算结果，不能对字长做任何限制。</li>\n<li>常见的编程语言支持固定精度的运算，因此“加法”和“乘法”这样的运算不同于它们在整数上的相应运算。</li>\n<li>无符号运算可视作一种形式的模运算。</li>\n<li><u><strong>算术运算溢出</strong></u>，是指完整的整数结果不能放到数据类型的字长限制中。（<u>执行C程序时，不会将溢出作为错误而发出信号</u>）</li>\n</ul>\n<h2 id=\"2-3-2二进制补码加法\"><a href=\"#2-3-2二进制补码加法\" class=\"headerlink\" title=\"2.3.2二进制补码加法\"></a>2.3.2二进制补码加法</h2><p>与无符号加法有相似之处，详见导引。</p>\n<p><a href=\"https://blog.csdn.net/Zwn_223/article/details/120168798\">1号导引</a></p>\n<p><a href=\"https://www.zhangshilong.cn/work/260595.html\">2号导引</a></p>\n<h2 id=\"2-3-3-二进制补码的非\"><a href=\"#2-3-3-二进制补码的非\" class=\"headerlink\" title=\"2.3.3 二进制补码的非\"></a>2.3.3 二进制补码的非</h2><p>一种有名的用来执行位级二进制补码的非（negation）的 技术是对每个位取反（或取补），然后将结果加一。（以后还请回看csapp   &gt;_&lt;）</p>\n<h2 id=\"2-3-4无符号乘法\"><a href=\"#2-3-4无符号乘法\" class=\"headerlink\" title=\"2.3.4无符号乘法\"></a>2.3.4无符号乘法</h2><ol>\n<li><p>0*0&#x3D;0</p>\n</li>\n<li><p>0*1&#x3D;0</p>\n</li>\n<li><p>1*0&#x3D;0</p>\n</li>\n<li><p>1*1&#x3D;1</p>\n<p>二进制乘法相似于十进制乘法。</p>\n</li>\n</ol>\n<h2 id=\"2-3-5二进制补码乘法\"><a href=\"#2-3-5二进制补码乘法\" class=\"headerlink\" title=\"2.3.5二进制补码乘法\"></a>2.3.5二进制补码乘法</h2><ul>\n<li>补码 * 补码 &#x3D; 补码（什么哦<em>^</em>）</li>\n<li>1、无符号数 * 无符号数 &#x3D; 无符号数<br>2、无符号数 * 有符号数 &#x3D; 有符号数<br>3、有符号数 * 无符号数 &#x3D; 有符号数<br>4、有符号数 * 有符号数 &#x3D; 有符号数</li>\n</ul>\n<h2 id=\"2-3-6与2-3-7-乘除2的幂\"><a href=\"#2-3-6与2-3-7-乘除2的幂\" class=\"headerlink\" title=\"2.3.6与2.3.7  乘除2的幂\"></a>2.3.6与2.3.7  乘除2的幂</h2><ul>\n<li><a href=\"https://blog.csdn.net/pumpi/article/details/104497529\">计算2的幂的解方法</a></li>\n<li><a href=\"https://www.cnblogs.com/gdjdsjh/p/5037673.html#:~:text=%E5%9C%A8%E5%A4%A7%E5%A4%9A%E6%95%B0%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%AD%EF%BC%8C%E9%99%A4%E6%B3%95%E8%A6%81%E6%AF%94%E4%B9%98%E6%B3%95%E8%BF%98%E6%9C%89%E5%8A%A0%E6%B3%95%E8%BF%99%E4%BA%9B\">具体解释1</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_40446252/article/details/109380011\">通过位运算来进行2的幂运算</a></li>\n</ul>\n<h1 id=\"2-4浮点\"><a href=\"#2-4浮点\" class=\"headerlink\" title=\"2.4浮点\"></a>2.4浮点</h1><p>用于精确的计算，提高运算精度。</p>\n<h2 id=\"2-4-1-二进制小数\"><a href=\"#2-4-1-二进制小数\" class=\"headerlink\" title=\"2.4.1  二进制小数\"></a>2.4.1  二进制小数</h2><ul>\n<li><p><strong>与十进制类似，用科学计数法表示（以2作指数底数）。</strong></p>\n</li>\n<li><p><strong>分为整数与小数两个部分，常常要在运算中分离处理</strong></p>\n</li>\n<li><p><strong>二进制小数末尾添上0或去掉0，小数的大小也不变，但是意义不一样。</strong></p>\n</li>\n<li><p><strong>正二进制整数或小数的开头添上0或去掉0，数的大小不变。负二进制整数或小数的开头添上1或去掉1，数的大小也不变。</strong></p>\n</li>\n</ul>\n<h2 id=\"2-4-2-IEEE浮点表示\"><a href=\"#2-4-2-IEEE浮点表示\" class=\"headerlink\" title=\"2.4.2  IEEE浮点表示\"></a>2.4.2  IEEE浮点表示</h2><p>IEEE标准754规定了三种浮点数格式：单精度、双精度、扩展精度。前两者正好对应C语言里头的float、double或者FORTRAN里头的real、double精度类型。</p>\n<p><a href=\"https://blog.csdn.net/weixin_43979304/article/details/108044754\">详见</a></p>\n<h2 id=\"2-4-3-数值示例\"><a href=\"#2-4-3-数值示例\" class=\"headerlink\" title=\"2.4.3 数值示例\"></a>2.4.3 数值示例</h2><p>来日方长：详见csapp  p87</p>\n<p><img src=\"C:\\Users\\陈林海\\Desktop\\有效协议\\截图20221002221650.png\" alt=\"截图20221002221650\"></p>\n<h2 id=\"2-4-4舍入\"><a href=\"#2-4-4舍入\" class=\"headerlink\" title=\"2.4.4舍入\"></a>2.4.4舍入</h2><p>因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似表示实数运算。</p>\n<p>舍入运算，可以找到最接近的匹配值。（需要定义舍入方向）</p>\n<p>舍入会存在偏差，（向偶数舍入可以避免偏差）</p>\n<h2 id=\"2-4-5-浮点运算\"><a href=\"#2-4-5-浮点运算\" class=\"headerlink\" title=\"2.4.5 浮点运算\"></a>2.4.5 浮点运算</h2><ul>\n<li><p>浮点数的加减运算分为5个步骤：对阶、尾数相加、尾数规格化、尾数舍入处理、溢出判断处理。</p>\n<h5 id=\"1-对阶：所谓对阶，就是让两个操作数阶数相同，以便进行加减。实现的方式是对较小数的尾数进行右移操作。对阶的原则是向高阶看齐。\"><a href=\"#1-对阶：所谓对阶，就是让两个操作数阶数相同，以便进行加减。实现的方式是对较小数的尾数进行右移操作。对阶的原则是向高阶看齐。\" class=\"headerlink\" title=\"1. 对阶：所谓对阶，就是让两个操作数阶数相同，以便进行加减。实现的方式是对较小数的尾数进行右移操作。对阶的原则是向高阶看齐。\"></a>1. 对阶：所谓对阶，就是让两个操作数阶数相同，以便进行加减。实现的方式是对较小数的尾数进行右移操作。对阶的原则是向高阶看齐。</h5><h5 id=\"2-尾数加减：将两个操作数的尾数相加减。在IEEE754标准中，对于规格化数来说在小数点前有一位隐藏位1，在加减过程中需要把它还原到尾数中。尾数加减的实质是原码的加减，\"><a href=\"#2-尾数加减：将两个操作数的尾数相加减。在IEEE754标准中，对于规格化数来说在小数点前有一位隐藏位1，在加减过程中需要把它还原到尾数中。尾数加减的实质是原码的加减，\" class=\"headerlink\" title=\"2. 尾数加减：将两个操作数的尾数相加减。在IEEE754标准中，对于规格化数来说在小数点前有一位隐藏位1，在加减过程中需要把它还原到尾数中。尾数加减的实质是原码的加减，\"></a>2. 尾数加减：将两个操作数的尾数相加减。在IEEE754标准中，对于规格化数来说在小数点前有一位隐藏位1，在加减过程中需要把它还原到尾数中。尾数加减的实质是原码的加减，</h5><h5 id=\"3-尾数规格化：加减完成的尾数形式未必满足IEEE754对于尾数的要求，即保留23位，小数点在第一个1之后。需要对尾数进行左规和右规，下面介绍一下左规和右规。左规：将尾数向左移，用于清除第一个1前面出现的0。左规伴随着阶码减少，在左规过程中要检测阶码是否发生下溢，即阶码达到最小值（0000-0000）。右规：将尾数向右移，用于两数相加后出现向高位进位的情况。因为两数相加最多进一位，所以右规最多一位。右规伴随着阶码的增加，在右规过程中要检测阶码是否发生上溢，即阶码达到最大值（1111-1111）。\"><a href=\"#3-尾数规格化：加减完成的尾数形式未必满足IEEE754对于尾数的要求，即保留23位，小数点在第一个1之后。需要对尾数进行左规和右规，下面介绍一下左规和右规。左规：将尾数向左移，用于清除第一个1前面出现的0。左规伴随着阶码减少，在左规过程中要检测阶码是否发生下溢，即阶码达到最小值（0000-0000）。右规：将尾数向右移，用于两数相加后出现向高位进位的情况。因为两数相加最多进一位，所以右规最多一位。右规伴随着阶码的增加，在右规过程中要检测阶码是否发生上溢，即阶码达到最大值（1111-1111）。\" class=\"headerlink\" title=\"3.尾数规格化：加减完成的尾数形式未必满足IEEE754对于尾数的要求，即保留23位，小数点在第一个1之后。需要对尾数进行左规和右规，下面介绍一下左规和右规。左规：将尾数向左移，用于清除第一个1前面出现的0。左规伴随着阶码减少，在左规过程中要检测阶码是否发生下溢，即阶码达到最小值（0000 0000）。右规：将尾数向右移，用于两数相加后出现向高位进位的情况。因为两数相加最多进一位，所以右规最多一位。右规伴随着阶码的增加，在右规过程中要检测阶码是否发生上溢，即阶码达到最大值（1111 1111）。\"></a>3.尾数规格化：加减完成的尾数形式未必满足IEEE754对于尾数的要求，即保留23位，小数点在第一个1之后。需要对尾数进行左规和右规，下面介绍一下左规和右规。左规：将尾数向左移，用于清除第一个1前面出现的0。左规伴随着阶码减少，在左规过程中要检测阶码是否发生下溢，即阶码达到最小值（0000 0000）。右规：将尾数向右移，用于两数相加后出现向高位进位的情况。因为两数相加最多进一位，所以右规最多一位。右规伴随着阶码的增加，在右规过程中要检测阶码是否发生上溢，即阶码达到最大值（1111 1111）。</h5><h5 id=\"4-尾数的舍入处理：\"><a href=\"#4-尾数的舍入处理：\" class=\"headerlink\" title=\"4. 尾数的舍入处理：\"></a>4. 尾数的舍入处理：</h5><h5 id=\"5-溢出判断：-在浮点数中是以阶码的溢出与否来作为评判标准的。单精度溢出分为上溢（指数大于等于127）和下溢（指数小于等于-126-。\"><a href=\"#5-溢出判断：-在浮点数中是以阶码的溢出与否来作为评判标准的。单精度溢出分为上溢（指数大于等于127）和下溢（指数小于等于-126-。\" class=\"headerlink\" title=\"5. 溢出判断：  在浮点数中是以阶码的溢出与否来作为评判标准的。单精度溢出分为上溢（指数大于等于127）和下溢（指数小于等于-126)。\"></a><img src=\"C:\\Users\\陈林海\\Desktop\\2020040900384131.png\" alt=\"2020040900384131\">5. 溢出判断：  在浮点数中是以阶码的溢出与否来作为评判标准的。单精度溢出分为上溢（指数大于等于127）和下溢（指数小于等于-126)。</h5></li>\n</ul>\n<p>详见：<a href=\"https://blog.csdn.net/gls_nuaa/article/details/105401372\">详见</a></p>\n<h1 id=\"2-5-小结\"><a href=\"#2-5-小结\" class=\"headerlink\" title=\"2.5 小结\"></a>2.5 小结</h1><p>虽然有很多不懂，但是就当作练习使用typora吧。以后回来看这些笔记怎么说也有帮助吧。（+-+）</p>\n",
            "tags": [
                "csapp"
            ]
        }
    ]
}