<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>TCworker • Posts by &#34;csapp&#34; tag</title>
    <link href="http://example.com" />
    <updated>2023-01-09T06:21:02.000Z</updated>
    <category term="csapp" />
    <category term="闲暇" />
    <category term="Linux" />
    <category term="图床" />
    <category term="Typroa" />
    <category term="blog" />
    <category term="hexo" />
    <category term="python" />
    <category term="pwn" />
    <category term="指针" />
    <category term="C语言" />
    <entry>
        <id>http://example.com/2023/01/09/csapp%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20I/</id>
        <title>csapp 第三章 I</title>
        <link rel="alternate" href="http://example.com/2023/01/09/csapp%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20I/"/>
        <content type="html">&lt;h1 id=&#34;csapp-第三章-i&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#csapp-第三章-i&#34;&gt;#&lt;/a&gt; csapp 第三章 I&lt;/h1&gt;
&lt;h1 id=&#34;前置点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#前置点&#34;&gt;#&lt;/a&gt; 前置点：&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;机器语言&lt;/code&gt; 是计算机能直接运行的语言，是二进制语言，属于低级语言； &lt;code&gt;汇编语言&lt;/code&gt; 是面向机器的低级语言，不能被机器直接识别，需要编译； &lt;code&gt;高级语言&lt;/code&gt; 是从人类的逻辑思维角度出发的计算机语言，不能被机器直接识别，需要编译。&lt;!--换言之，机器语言和汇编语言所面向的机器，是为机器服务的；而高级语言是为了便于人开展工作，是为程序员服务的。--&gt;&lt;/p&gt;
&lt;p&gt;计算机语言具有高级语言和低级语言之分。而高级语言又主要是相对于汇编语言而言的，它是较接近自然语言和数学公式的编程，基本脱离了机器的硬件系统，用人们更易理解的方式编写程序。&lt;/p&gt;
&lt;p&gt;低级语言分机器语言（二进制语言）和汇编语言（符号语言），这两种语言都是面向机器的语言，和具体机器的指令系统密切相关。机器语言用指令代码编写程序，而符号语言用指令助记符来编写程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;机器语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;机器语言是一种指令集的体系，它是用二进制代码表示的语言，是计算机唯一可以&lt;u&gt;直接识别和执行&lt;/u&gt;的语言，它具有计算机可以直接执行、简洁、运算速度快等优点，但它的直观性差 (其实是相当差，毕竟没人会喜欢满屏幕的 0 和 1)，非常容易出错，程序的检查和调试都比较困难，此外对机器的&lt;u&gt;依赖型&lt;/u&gt;也很强。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;汇编语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;汇编语言是面向机器的程序设计语言，它是为了解决机器语言难以理解和记忆的缺点，用易于理解和记忆的名称和符号表示机器指令中的操作码，这样用符号代替机器语言的二进制码，就把机器语言变成了汇编语言；于是汇编语言亦称为符号语言。&lt;!--汇编语言用简易的名称和符号来表示操作码，这使得代码的编写和检查提供了巨大的便捷--&gt;&lt;/p&gt;
&lt;p&gt;使用汇编语言编写的程序，机器&lt;u&gt;不能直接识别&lt;/u&gt;，要由一种程序将汇编语言翻译成机器语言，这种起翻译作用的程序叫汇编程序，汇编程序是系统软件中语言处理系统软件。汇编程序把汇编语言翻译成机器语言的过程称为汇编。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高级语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;高级语言为用户提供了一种既接近于自然语言，又可以使用数学表达式，还相对独立于机器的工作方式。与汇编语言一样，机器也不能直接执行用高级语言编写的程序。&lt;!--牛蛙--&gt;&lt;/p&gt;
&lt;p&gt;而高级语言并不是特指的某一种具体的语言，而是包括很多编程语言，如目前流行的 java，c，c++，C#，pascal，python 等等。&lt;!--听说掌握七门甚至六门高级语言，就可以召唤神龙（bushi）--&gt;&lt;/p&gt;
&lt;p&gt;高级语言有更强的表达能力，可方便地表示数据的运算和程序的控制结构，能更好的描述各种算法，而且容易学习掌握。但它编译生成的程序代码一般比用汇编程序语言设计的程序代码要长，执行的速度也慢。&lt;/p&gt;
&lt;h1 id=&#34;31-历史观点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#31-历史观点&#34;&gt;#&lt;/a&gt; 3.1 历史观点&lt;/h1&gt;
&lt;p&gt;全是图片😕, 毕竟我不是历史学家。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202301081146247.bmp&#34; alt=&#34;capture_20230108114407972&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202301081146870.bmp&#34; alt=&#34;capture_20230108114433881&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202301081147348.bmp&#34; alt=&#34;capture_20230108114521435&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202301081148541.bmp&#34; alt=&#34;capture_20230108114533692&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;32-程序编码&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#32-程序编码&#34;&gt;#&lt;/a&gt; 3.2 程序编码&lt;/h1&gt;
&lt;h2 id=&#34;a&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#a&#34;&gt;#&lt;/a&gt; A&lt;/h2&gt;
&lt;p&gt;代码的编译，一般使用第二级优化，因为这是性能和便捷度的最好的权衡 (具体的原有的话，现在我还不到)。实际上的编译是一个比较复杂的过程，有&lt;u&gt;预处理&lt;/u&gt;，&lt;u&gt;编译&lt;/u&gt;，&lt;u&gt;汇编&lt;/u&gt;，&lt;u&gt;链接&lt;/u&gt; 四个阶段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;预处理阶段&lt;/strong&gt;。预处理器（cpp）根据以字符 #开头的命令，修改原始的 C 程序。比如 hello.c 中第一行的 #include&amp;lt;stdio.h&amp;gt; 命令告诉预处理器读取系统头文件&lt;u&gt;stdio.h&lt;/u&gt;的内容，并把它直接插入程序文本中，结果就得到了另一个 C 程序，通常是以.i 作为文件扩展名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译阶段&lt;/strong&gt;。编译器（ccl）将文本文件 hello.i&lt;strong&gt; 翻译&lt;/strong&gt;成文本文件 hello.s，它包含一个汇编语言程序。&lt;u&gt;汇编语言程序中的每条语句都以一种标准的文本格式确切的描述了一条低级机器语言指令&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;汇编阶段&lt;/strong&gt;。汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种可重定位目标程序的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它的字节编码是机器语言指令而不是字符，如果我们在文本文件中打开 hello.o 文件，看到的将是一堆乱码。&lt;!--不可读性--&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链接阶段&lt;/strong&gt;。链接器（ld）负责处理合并目标代码，生成一个可执行目标文件，可以被加载到内存中，由系统执行。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;strong&gt;&lt;u&gt;tips：&lt;/u&gt;&lt;/strong&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顾名思义，&lt;strong&gt;源代码&lt;/strong&gt;是程序的源代码，是由程序员编写的&lt;u&gt;原始文件&lt;/u&gt;。源代码是人类可读的，但是机器无法直接理解它。而目标代码是机器可执行文件，其中包含由编译器生成的二进制形式的机器指令。源代码作为编译器的输入，而目标代码是编译器的输出，并且是一个二进制文件，具有程序员在源代码中给出的指令。&lt;/li&gt;
&lt;li&gt;目标代码是特定于系统体系结构的，即在一台计算机上由编译器生成的文件可能无法在具有不同系统体系结构或基础结构的其他计算机上运行。&lt;!--就是说，电脑不同的话，同一份目标代码可能无法运行--&gt;。并且，目标代码对应于源代码，所以修改源代码后，每次需要编译源代码以反映目标代码中的更改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;b&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#b&#34;&gt;#&lt;/a&gt; B&lt;/h2&gt;
&lt;p&gt;汇编代码接近于机械代码，其基本特点是具有良好的可读性，能够理解汇编代码以及它是如何与原始的 C 语言代码相对应的，是理解计算机如何执行程序的关键一步。&lt;!--可以说，机械代码是生黄瓜，汇编代码是腌黄瓜，两者相近，但后者风味更佳--&gt;【虽然对我来说，两种都不好吃🙄】&lt;/p&gt;
&lt;p&gt;通过了解汇编语言，可以了解到：一些通常对 C 程序员来说不可见的处理器的状态，比如程序计数器，整数计算器等的状态。相比于 C，汇编代码只是&lt;u&gt;简单地将存储器看成一个很大的、按字节寻址的数组&lt;/u&gt;。C 中的聚集数据类型，例如数组和结构，在汇编代码中&lt;u&gt;也是以连续的字节表示&lt;/u&gt;。而如果是对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，不区分指针和整数。&lt;!--注意两者的差异性，但很多时候还是通性居多--&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;程序存储器&lt;/em&gt;（program memory）包含程序的目标代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的存储器块（比如说用 malloc 库函数分配的）。😖&lt;/p&gt;
&lt;p&gt;&lt;em&gt;程序存储器&lt;/em&gt;是用&lt;u&gt;&lt;strong&gt;虚拟地址&lt;/strong&gt;&lt;/u&gt;来寻址的。在任意给定的时刻，只有有限的一部分虚拟地址是&lt;mark&gt;合法&lt;/mark&gt;的。例如，虽然 IA32 的 32 位地址可以寻址 4GB 的地址范围，但是一个通常的程序只会访问几 M 字节。操作系统负责管理虚拟地址空间，将虚拟地址转换成实际处理器存储器（processor memory）中的物理地址。&lt;!--这个合法应该不能咨询罗翔老师吧--&gt;&lt;/p&gt;
&lt;p&gt;&lt;u&gt;一条机器指令只执行非常基本的操作&lt;/u&gt;。例如，将两个存放在寄存器中的数字相加，在存储器和寄存器之间传递数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令序列，从而实现象算术表达式求值、循环或过程调用和返回这样的程序结构。&lt;/p&gt;
&lt;h2 id=&#34;c&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#c&#34;&gt;#&lt;/a&gt; C&lt;/h2&gt;
&lt;p&gt;假设我们写了一个 C 代码文件 code.c ，在命令行上使用 “—S” 选项，就能看到 C 编译器产生的&lt;mark&gt;汇编代码&lt;/mark&gt;：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;unix&amp;gt; gcc -02 -S code.c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;编译器会产生一个&lt;u&gt;汇编文件&lt;/u&gt; code.s，但是不做其他进一步的工作（通常情况下，它还会调用汇编器产生目标代码文件）。&lt;br&gt;
GCC 是按照它自己的格式产生汇编代码的，这种格式称为 GAS（Gnu ASsembler，GNU 汇编器）。这种格式同 Intel 文档中的格式以及微软编译器使用的格式&lt;mark&gt;差异很大&lt;/mark&gt;。&lt;br&gt;
汇编代码文件包含各种声明，包括下面所示：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sum:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;pushl %ebp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;movl %esp,%ebp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;movl 12(%ebp),%eax &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;addl 8(%ebp),%eax &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;addl %eax,accum&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;movl %ebp,%esp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;popl %ebp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ret&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中每个缩进去的行都对应于一条机器指令 (一一对应，依次执行)。比如，pushl 指令表示应该将寄存器％ebp 的内容压入程序栈中。这段代码中已经除去了所有关于局部变量名或数据类型的信息，但我们还是看到了一个对全局变量 accum 的引用，这是因为编译器还不能确定这个变量会放在存储器中的哪个位置。&lt;br&gt;
如果我们使用 “—c” 命令行选项，GCC 会&lt;u&gt;&lt;strong&gt;编译并汇编&lt;/strong&gt;&lt;/u&gt;该代码：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;unix&amp;gt; gcc -02-c code.c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这就会产生目标代码文件 code．o，它是二进制格式的，所以无法被我们直接读。852 字节的文件 code．o 中有一段 19 字节的十六进制表示的序列：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;55 89 e5 8b 45 0c 03 45 08 01 05 00 00 00 00 89 ec 5d c3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这就是对应于上面列出的&lt;strong&gt;汇编指令&lt;/strong&gt;的&lt;mark&gt;目标代码&lt;/mark&gt;。从中得到的重要信息就是：&lt;u&gt;机器实际执行的程序只是对一系列指令进行编码的字节序列。机器对产生这些指令的源代码几乎一无所知&lt;/u&gt;。&lt;!--正因如此，仅仅凭借目标代码是难以反推出源代码的--&gt;&lt;/p&gt;
&lt;p&gt;那么，如何找到程序的字节表示？😕&lt;br&gt;
首先，1. 我们用&lt;u&gt;&lt;strong&gt;反汇编器&lt;/strong&gt;&lt;/u&gt;来确定函数 sum 的代码长是 19 字节。2. 我们在文件 code.o 上运行 GNU 调试工具 GDB，输入命令：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb) x/19xb sum&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该命令会告诉&lt;strong&gt; GDB&lt;/strong&gt;&lt;u&gt;检查（简写为 “x”）19 个十六进制格式（也简写为 “x”）的字节（简写为 “b”）&lt;/u&gt;。你会发现，GDB 有很多有用的特性可以用来分析机器级程序。&amp;lt;!–虽然我感觉没怎么发现 -_—&amp;gt;&lt;/p&gt;
&lt;p&gt;要&lt;u&gt;查看&lt;/u&gt;目标代码文件的&lt;strong&gt;内容&lt;/strong&gt;，有一类称为&lt;mark&gt;反汇编器&lt;/mark&gt;（disassembler）的程序的可以实现，这些程序根据目标代码生成一种类似于汇编代码的格式 (有汇编器就一定有反汇编器的吧，这并不奇怪😃）， 在 Linux 系统中，带 “—d” 命令行选项的程序 OBJDUMP（代表 “object dump”）可以充当这个角色：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;unix&amp;gt; objdump -d code.o&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结果是（这里，我们在左边增加了行号，在右边增加了注解）：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202301082154615.bmp&#34; alt=&#34;capture_20230108215425729&#34;&gt;&lt;/p&gt;
&lt;p&gt;在左边，我们看到按照前面给出的字节顺序排列的 19 个十六进制字节值，它们分成了一些组，每组有 1～6 个字节。&lt;u&gt;&lt;strong&gt;每组都是一条指令，右边是等价的汇编语言&lt;/strong&gt;&lt;/u&gt;。其中一些特性值得说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IA32&lt;mark&gt; 指令长度&lt;/mark&gt;从 1～15 个字节不等。&lt;u&gt;&lt;strong&gt;指令编码被设计成使常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多&lt;/strong&gt;&lt;/u&gt;。【将常常出现的&lt;strong&gt;指令&lt;/strong&gt;趋于简化，这不难理解】&lt;/li&gt;
&lt;li&gt;指令格式是按照这样一种方式设计的，从某个&lt;mark&gt;给定位置&lt;/mark&gt;开始，&lt;u&gt;&lt;strong&gt;可以将字节惟一地解码成机器指令&lt;/strong&gt;&lt;/u&gt;(即使看起来目标代码很冗杂，但却是高度有序的)。例如，只有指令 pushl％ebp 是以字节值 55 开头的。&lt;/li&gt;
&lt;li&gt;&lt;u&gt;&lt;strong&gt;反汇编器&lt;/strong&gt;只是根据目标文件中的字节序列来确定汇编代码的&lt;/u&gt;。它&lt;strong&gt;不需要&lt;/strong&gt;访问程序的源代码或汇编代码。&lt;!--反汇编器是从目标代码出发，反推回汇编代码的哦--&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反汇编器&lt;/strong&gt;使用的&lt;u&gt;指令命名规则&lt;/u&gt;与 GAS 使用的有些细微的&lt;strong&gt;差别&lt;/strong&gt;。在我们的示例中，它省略了很多指令结尾的 “1”。&lt;/li&gt;
&lt;li&gt;&lt;u&gt;与 code.s 中的汇编代码相比，我们还发现结尾多了一条&lt;strong&gt; nop 指令&lt;/strong&gt;。这条指令根本&lt;mark&gt;不会被执行&lt;/mark&gt;&lt;/u&gt;&lt;/li&gt;
&lt;li&gt;它在过程返回指令之后，即使执行了也不会有任何影响（所以称之为 nop，是 “no operation” 的简写，通常读作 “noop”）。&lt;u&gt;编译器插入这样的指令是为了填充存储该过程的空间。&lt;/u&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;生成实际可执行的代码需要对一组&lt;strong&gt;目标代码文件&lt;/strong&gt;运行&lt;mark&gt;链接器&lt;/mark&gt;，而这一组目标代码文件中必须含有一个 **&lt;u&gt;main 函数&lt;/u&gt;**。假设在文件 main.c 中有下面这样的函数：&lt;!--链接，就像汽车生产过程中的最后部件组装一样吧，组装好了就可以上路了--&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;  int main() &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	return sum(1,3); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后，我们用如下方法生成可执行文件 test：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;unix&amp;gt; gcc -02 -o prog code.o main.c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;文件 prog 变成了 11667 字节，因为它不仅包含我们的两个过程的代码，还包含了用来启动和终&lt;/p&gt;
&lt;p&gt;止程序的信息，以及用来与操作系统交互的信息（把一切信息编织起来）。我们也可以反汇编 prog 文件：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;unix&amp;gt; objdump -d prog&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;反汇编器会抽取出各种代码序列，包括下面这段：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202301082202515.bmp&#34; alt=&#34;capture_20230108220110430&#34;&gt;&lt;/p&gt;
&lt;p&gt;注意，这段代码与 code.c 反汇编产生的代码几乎完全一样。一个主要的区别是左边列出的地址不同 (&lt;u&gt;链接器将代码的地址移到一段不同的地址范围&lt;/u&gt;)。第二个不同之处在于链接器终于确定存储全局变量 accum 的地址。code．o 反汇编代码的第 6 行中，accum 的地址还是 0。prog 的反汇编代码中，地址就设成 0x8049464。这可以从指令的汇编代码格式中看到，还可以从指令的最后四个字节中看出来，从最低位到最高位列出的就是 64940408。&lt;!-- 链接 会将代码的地址确定并改变--&gt;&lt;/p&gt;
&lt;h2 id=&#34;d&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#d&#34;&gt;#&lt;/a&gt; D&lt;/h2&gt;
&lt;p&gt;GCC 产生的汇编代码有点难读，它包含一些我们不需要关心的信息。另外，它不提供任何程序的描述或它是如何工作的描述。例如，假设文件 simple.c 包含下列代码：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;int simple(int *xp, int y) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	int t=*xp+y; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	*xp=t; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	return t; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当带选项 “—S” 运行 GCC 时，它产生下面的文件 simple.s：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;.file &amp;quot;simple.c&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;.version	&amp;quot;01.01&amp;quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;gcc2_compiled.: &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;.text&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  .align 4 &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;.globl simple &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; .type	simple,@function &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;simple:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; pushl %ebp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; mov1 %esp,&amp;amp;ebp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mov1 8(%ebp),%eax &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mov1 (%eax), %edx &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;add1	12(%ebp) , %edx &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mov1 %edx, (%eax)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mov1 %edx,%eax &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;movl %ebp,%esp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;popl %ebp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ret &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;.Lfe1: &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;.size	simple,.Lfel-simple &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;.ident	&amp;quot;GCC:(GNU) 2.95.3 20010315 (release)&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;文件包含的信息多于我们实际需要的。所有以 “.” 开头的行都是指导汇编器和链接器的命令（directive），不过我们&lt;u&gt;通常可以忽略这些行&lt;/u&gt;。另一方面，也没有关于这些指令是干什么用的以及它们与源代码之间关系的解释说明。😄&lt;/p&gt;
&lt;p&gt;为了更清楚地说明汇编代码，我们将给出汇编代码的&lt;mark&gt;格式&lt;/mark&gt;，包括 **&lt;u&gt;行号和解释性说明&lt;/u&gt;**。对于我们的示例，带解释的汇编代码是像下面这样的：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;simple: &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;pushl %ebp	Save frame pointer &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;movl %esp,%ebp	Create new frame pointer &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mov1 8(%ebp), %eax	Get xp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;movl (%eax),&amp;amp;edx	Retrieve*xp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;addl 12(%ebp),%edx	Add y to get t &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mov1 %edx, (%eax)	Store t at *xp &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mov1 %edx,%eax	Set t as return value &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;movl %ebp,%esp	Reset stack pointer &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;popl %ebp	Reset frame pointer&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ret			Return&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通常我们只会给出与要讨论内容相关的代码行。每一行的左边都有编号供引用，右边是注释，简单地描述指令的效果以及它与原始 C 代码中的计算操作的关系。这是一种汇编语言程序员写代码的风格。&lt;/p&gt;
&lt;h1 id=&#34;33-数据格式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#33-数据格式&#34;&gt;#&lt;/a&gt; 3.3  数据格式&lt;/h1&gt;
&lt;p&gt;由于是从 16 位体系结构扩展成 32 位的，Intel 用术语 ==“字（word）”&lt;mark&gt; 表示&lt;strong&gt; 16 位数据类型&lt;/strong&gt;。因此，&lt;br&gt;
称&lt;strong&gt; 32 位数&lt;/strong&gt;为&lt;/mark&gt; “双字（doublewords）”&lt;mark&gt;，称&lt;strong&gt; 64 位数&lt;/strong&gt;为&lt;/mark&gt; “四字（quadwords）”==。我们将遇到的大多数指&lt;br&gt;
令都是对字节或双字操作的。&lt;/p&gt;
&lt;p&gt;图 3.1 给出了对应 C 基本数据类型的机器表示。注意，&lt;u&gt;大多数常用数据类型都是作为&lt;strong&gt;双字&lt;/strong&gt;存储&lt;/u&gt;&lt;br&gt;
&lt;u&gt;的&lt;/u&gt;。其中，包括普通整数（int）和长整数（longint），无论它们是否有符号。此外，所有的指针（在&lt;br&gt;
此用 char * 表示）&lt;strong&gt;都是 4 字节的双字&lt;/strong&gt;。处理字符串数据时，通常用到字节。浮点数有三种形式：单&lt;br&gt;
精度（4 字节）值，对应于 C 数据类型 foat；双精度（8 字节）值，对应于 C 数据类型 double：和&lt;br&gt;
扩展精度（10 字节）值。GCC 用数据类型 1ongdouble 来表示扩展精度的浮点值。为了提高存储器&lt;br&gt;
系统的性能，它将这样的浮点数存储成 12 字节数，待会儿我们会讨论这个问题。虽然 ANSIC 标准&lt;br&gt;
包括 longdouble 数据类型，但是对大多数编译器和机器组合来说，它的实现和普通 double 的 8 字节&lt;br&gt;
格式是一样的。对 GCC 和 IA32 的组合来说，支持扩展精度是很少见的。&lt;!--这些知识是我们比较熟悉的，也不会有太多的困惑感--&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://tcwokor.oss-cn-chengdu.aliyuncs.com/img/202301082151608.bmp&#34; alt=&#34;capture_20230108175905491&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图 3.1 所示，&lt;strong&gt;&lt;u&gt;GAS 中的每个操作都有一个字符后级，表明操作数的大小&lt;/u&gt;&lt;/strong&gt;。例如，mov（传送&lt;br&gt;
数据）指令有三种形式：&lt;mark&gt;movb（传送字节）、movw（传送字）和 movl（传送双字）&lt;/mark&gt;。后缀 ==“1”&lt;mark&gt; 用来&lt;br&gt;
表示双字，因为在许多机器上，32 位数都称为&lt;/mark&gt; “长字（longword）”&lt;mark&gt;，这是沿用以 16 位字为标准的&lt;br&gt;
程序的机器级表示时代的习惯造成的。&lt;u&gt;注意，GAS 使用后缀&lt;/u&gt;&lt;/mark&gt; “1”== 来同时表示 4 字节的整数和 8 字节的双精度浮点数。这不会产生岐义，因为 **&lt;u&gt;浮点数使用的是一组完全不同的指令和寄存器。&lt;/u&gt;**&lt;/p&gt;
</content>
        <category term="csapp" />
        <updated>2023-01-09T06:21:02.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/10/12/csapp%E7%AC%ACll%E7%AB%A0/</id>
        <title>csapp第二章</title>
        <link rel="alternate" href="http://example.com/2022/10/12/csapp%E7%AC%ACll%E7%AB%A0/"/>
        <content type="html">&lt;h1 id=&#34;csapp第二章可能没什么帮助就随便看看吧&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#csapp第二章可能没什么帮助就随便看看吧&#34;&gt;#&lt;/a&gt; csapp 第二章（可能没什么帮助，就随便看看吧）&lt;/h1&gt;
&lt;p&gt;（现代计算机以二进制存储信息。相较于十进制，它能更好的适配计算机，能够更可靠的进行信息的表示、存储传输；用不同的位组合来表示元素；三种重要的数字编码：&lt;u&gt;无符号编码&lt;/u&gt;，&lt;u&gt;二进制补码&lt;/u&gt;，&lt;u&gt;浮点数编码&lt;/u&gt;；）&lt;/p&gt;
&lt;h1 id=&#34;21信息存储&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#21信息存储&#34;&gt;#&lt;/a&gt; 2.1 信息存储&lt;/h1&gt;
&lt;p&gt;1. 字节（byte）是&lt;strong&gt; 8 位&lt;/strong&gt;的块，&lt;u&gt;作为最小的可寻址的存储器单位&lt;/u&gt;&amp;lt;而不是单独的位&amp;gt;.&lt;/p&gt;
&lt;p&gt;2. 存储器中每个字节由一个惟一的数字标识，这称之为他的&lt;u&gt;地址&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;3. 所有可能地址的集合，称为&lt;u&gt;虚拟地址空间&lt;/u&gt;。&amp;lt;像一个分好类别的仓库吧？&amp;gt;&lt;/p&gt;
&lt;p&gt;4. 编译和运行时，系统将存储空间划分为更可管理的单元，来存放不同程序对象（程序数据、指令和控制信息）。&amp;lt;分类存放，便于之后的管理与取用&amp;gt;&lt;/p&gt;
&lt;h2 id=&#34;211十六进制表示法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#211十六进制表示法&#34;&gt;#&lt;/a&gt; 2.1.1 十六进制表示法&lt;/h2&gt;
&lt;p&gt;因为二进制表示太冗长，而十进制与位模式的互相转化很麻烦，两种符号表示法都比较麻烦。所以采取 16 进制来书写位模式。编写机械级程序常常需要手工地进行十、二、十六之间的转换。&lt;u&gt;需要掌握进制之间的转化方法&lt;/u&gt;。&lt;/p&gt;
&lt;h2 id=&#34;212-字&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#212-字&#34;&gt;#&lt;/a&gt; 2.1.2 字&lt;/h2&gt;
&lt;p&gt;每台计算机都有一个字长（world size），指明整数和指针数据的标称大小（normal size）。&lt;strong&gt;字长 决定虚拟地址的最大大小&lt;/strong&gt;。&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNDAyNDc1L2FydGljbGUvZGV0YWlscy8xMjQ4MDk5MjE=&#34;&gt;字长是什么&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;213-数据大小&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#213-数据大小&#34;&gt;#&lt;/a&gt; 2.1.3 数据大小&lt;/h2&gt;
&lt;p&gt;计算机和编译器用不同方式来编码数字，如不同长度的整数和浮点数，从而支持多种数字格式。（程序员应该提高他们编写程序的可移植性，就是说，使得程序对不同数据类型的准确大小不敏感）&amp;lt;就是可以在其他设备，其他系统上运行？&amp;gt;&lt;/p&gt;
&lt;h2 id=&#34;214寻址和字节顺序&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#214寻址和字节顺序&#34;&gt;#&lt;/a&gt; 2.14 寻址和字节顺序&lt;/h2&gt;
&lt;p&gt;对于跨越多字节的程序对象，要建立两个规则：1. 对象地址是什么；2. 在存储器中如何对这些字节排序。几乎所有机器，&lt;u&gt;多字节对象都被存储为连续的字节序列，对象的地址为&lt;strong&gt;所使用字节序列中的最小地址&lt;/strong&gt;。&lt;/u&gt;（越小越精确，要找到对象的精确地址？）&lt;/p&gt;
&lt;h2 id=&#34;215-表示字符串&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#215-表示字符串&#34;&gt;#&lt;/a&gt; 2.15 表示字符串&lt;/h2&gt;
&lt;p&gt;字符串被编码为一个&lt;strong&gt;以 null（其值）字符结尾&lt;/strong&gt;的字符数组。每个字符由标准码表示，常用 ASCII 字符码。（&lt;u&gt;文本数据比二进制数据具有更强的平台独立性&lt;/u&gt;）&amp;lt;不是特别理解・-・&amp;gt;&lt;/p&gt;
&lt;h2 id=&#34;216-表示代码&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#216-表示代码&#34;&gt;#&lt;/a&gt; 2.1.6 表示代码&lt;/h2&gt;
&lt;p&gt;多数情况下，&lt;u&gt;不同机器类型使用不同且不兼容的指令和编码方式。&lt;/u&gt;二进制代码很少能在不同机器和操作系统组合之间移植。&lt;/p&gt;
&lt;h2 id=&#34;217-布尔代数和环&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#217-布尔代数和环&#34;&gt;#&lt;/a&gt; 2.1.7 布尔代数和环&lt;/h2&gt;
&lt;p&gt;因为二进制是计算机编码、存储和操作信息的核心，所以围绕数值 0 和 1 已经演化出了丰富的数学知识体系。（I compeletly don’t understand what it wants telling me）&lt;/p&gt;
&lt;h2 id=&#34;218-c中的位级运算&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#218-c中的位级运算&#34;&gt;#&lt;/a&gt; 2.1.8  C 中的位级运算&lt;/h2&gt;
&lt;p&gt;C 的一个很有用的特性就是它是支持按位布尔运算，在布尔运算中使用的那些符号就是在 C 中使用的。（&lt;u&gt;确定一个位级表达式的结果的最好的方法就是将十六进制参数扩展成他们的二进制表示，执行二进制运算，然后再转换为十六进制。&amp;lt;/u）&lt;/p&gt;
&lt;h2 id=&#34;219-c中的逻辑运算&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#219-c中的逻辑运算&#34;&gt;#&lt;/a&gt; 2.1.9   C 中的逻辑运算&lt;/h2&gt;
&lt;p 逻辑运算认为所有非零参数都表示true，而参数零表示false=&#34;&#34;&gt;C 中提供了一系列的逻辑运算符，但逻辑运算容易与位级运算相混淆，而他们的功能又是完全不同的。&lt;/p&gt;
&lt;h2 id=&#34;2110-c中的移位运算&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2110-c中的移位运算&#34;&gt;#&lt;/a&gt; 2.1.10  C 中的移位运算&lt;/h2&gt;
&lt;p&gt;C 提供了一系列的移位运算，有向左或向右移位模式。（移动后要用 0 进行补位）&lt;/p&gt;
&lt;h1 id=&#34;22-整数表示&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#22-整数表示&#34;&gt;#&lt;/a&gt; 2.2 整数表示&lt;/h1&gt;
&lt;h2 id=&#34;221整型数据类型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#221整型数据类型&#34;&gt;#&lt;/a&gt; 2.2.1 整型数据类型&lt;/h2&gt;
&lt;p&gt;C 支持多种整型数据类型 —— 表示有限范围的整数。如 char、short、int、、long。C 标准定义了每种数据类型必须能够表示的最小值范围。具体而言，数据类型的取值会有差异。&lt;/p&gt;
&lt;h2 id=&#34;222无符号和二进制补码编码&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#222无符号和二进制补码编码&#34;&gt;#&lt;/a&gt; 2.2.2 无符号和二进制补码编码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;二进制的补码范围是不对称的，容易产生错误。&lt;/li&gt;
&lt;li&gt;最大无符号值刚好比二进制补码的最大值的两倍大一（1）点。&lt;/li&gt;
&lt;li&gt;尽管 C 的标准没有要求用二进制补码形式来表示有符号整数，但几乎所有机器都是这么的。&lt;/li&gt;
&lt;li&gt;对有符号数，其最高有效位也称为符号位（sign bit），0 为正，1 为负。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;223有符号数和无符号数之间的转换&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#223有符号数和无符号数之间的转换&#34;&gt;#&lt;/a&gt; 2.2.3 有符号数和无符号数之间的转换&lt;/h2&gt;
&lt;p&gt;依托两者之间的映射关系进行转换，具体方法如有需要：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aGlkYW8uYmFpZHUuY29tL3F1ZXN0aW9uLzUxMjk3MjAwLmh0bWw=&#34;&gt;有符号数如何与无符号数转换&lt;/span&gt;                    &amp;lt;用 ctrl + 点击&amp;gt;&lt;/p&gt;
&lt;h2 id=&#34;224-c中的有符号与无符号数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#224-c中的有符号与无符号数&#34;&gt;#&lt;/a&gt; 2.2.4 C 中的有符号与无符号数&lt;/h2&gt;
&lt;p&gt;C 支持所有整数数据类型的有符号与无符号运算。尽管 C 标准没有指定某种有符号数的表示，但几乎所有机器都使用二进制补码。通常，大多数数字都是默认有符号的。（另外，当一种类型的表达式被赋值给另一种类型的变量时，转换是隐式发生的）&lt;/p&gt;
&lt;p&gt;当执行一个运算时，如果它的一个运算数是有符号而另一个是无符号，那么 C 将有符号参数类型转换为无符号数，并假设两数非负，并执行。（于一些情况下会导致运算错误）&lt;/p&gt;
&lt;h2 id=&#34;225扩展一个数字的位表示&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#225扩展一个数字的位表示&#34;&gt;#&lt;/a&gt; 2.2.5 扩展一个数字的位表示&lt;/h2&gt;
&lt;p&gt;一个常见的运算是在不同字长的整数之间转换，同时保持数值不变。而当目标类型太小了，则转换可能失效，但从较小到较大，应该总可能的。（*&lt;em&gt; 将一个无符号数转换为一个更大的数据类型，只要简单的在表示的开头添加 0，这种运算被称为零扩展（zero extension）；要将一个二进制补码数字转换俄日一个更大的数据类型，规则是执行一个符号扩展（sign extension），在表示中添加最高有效位的值）。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;从一个数据大小到另一个数据大小，以及&lt;u&gt;无符号和有符号数字之间的转换的相对顺序&lt;/u&gt;能够影响一个程序的行为。&lt;/p&gt;
&lt;h2 id=&#34;226-截断数字&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#226-截断数字&#34;&gt;#&lt;/a&gt; 2.2.6 截断数字&lt;/h2&gt;
&lt;p&gt;详见：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpcGFucGFuOTAwNzIxL2FydGljbGUvZGV0YWlscy8xMjA4MDQ0MTc=&#34;&gt;截断数字&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;227有符号数和无符号数的建议&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#227有符号数和无符号数的建议&#34;&gt;#&lt;/a&gt; 2.2.7 有符号数和无符号数的建议&lt;/h2&gt;
&lt;p&gt;1. 尽量不要在你的代码中使用无符号数，以免增加不必需要的复杂性。&lt;/p&gt;
&lt;p&gt;2. 尽量使用像 int 那样的有符号类型，这样在涉及升级混合类型的复杂细节时，不必担心边界情况。&lt;/p&gt;
&lt;p&gt;3. 只有在使用位段和二进制掩码时，才可以用无符号数。应该在表达式中使用强制类型转换，使操作数均为有符号或无符号数，这样就不必由编译器来选择结果的类型。&lt;/p&gt;
&lt;h1 id=&#34;23-整数运算&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#23-整数运算&#34;&gt;#&lt;/a&gt; 2.3 整数运算&lt;/h1&gt;
&lt;h2 id=&#34;231无符号加法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#231无符号加法&#34;&gt;#&lt;/a&gt; 2.3.1 无符号加法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;要想完整地表示运算结果，不能对字长做任何限制。&lt;/li&gt;
&lt;li&gt;常见的编程语言支持固定精度的运算，因此 “加法” 和 “乘法” 这样的运算不同于它们在整数上的相应运算。&lt;/li&gt;
&lt;li&gt;无符号运算可视作一种形式的模运算。&lt;/li&gt;
&lt;li&gt;&lt;u&gt;&lt;strong&gt;算术运算溢出&lt;/strong&gt;&lt;/u&gt;，是指完整的整数结果不能放到数据类型的字长限制中。（&lt;u&gt;执行 C 程序时，不会将溢出作为错误而发出信号&lt;/u&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;232二进制补码加法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#232二进制补码加法&#34;&gt;#&lt;/a&gt; 2.3.2 二进制补码加法&lt;/h2&gt;
&lt;p&gt;与无符号加法有相似之处，详见导引。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1p3bl8yMjMvYXJ0aWNsZS9kZXRhaWxzLzEyMDE2ODc5OA==&#34;&gt;1 号导引&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuemhhbmdzaGlsb25nLmNuL3dvcmsvMjYwNTk1Lmh0bWw=&#34;&gt;2 号导引&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;233-二进制补码的非&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#233-二进制补码的非&#34;&gt;#&lt;/a&gt; 2.3.3 二进制补码的非&lt;/h2&gt;
&lt;p&gt;一种有名的用来执行位级二进制补码的非（negation）的 技术是对每个位取反（或取补），然后将结果加一。（以后还请回看 csapp   &amp;gt;_&amp;lt;）&lt;/p&gt;
&lt;h2 id=&#34;234无符号乘法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#234无符号乘法&#34;&gt;#&lt;/a&gt; 2.3.4 无符号乘法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;0*0=0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;0*1=0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1*0=0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1*1=1&lt;/p&gt;
&lt;p&gt;二进制乘法相似于十进制乘法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;235二进制补码乘法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#235二进制补码乘法&#34;&gt;#&lt;/a&gt; 2.3.5 二进制补码乘法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;补码 * 补码 = 补码（什么哦 *^*）&lt;/li&gt;
&lt;li&gt;1、无符号数 * 无符号数 = 无符号数&lt;br&gt;
 2、无符号数 * 有符号数 = 有符号数&lt;br&gt;
 3、有符号数 * 无符号数 = 有符号数&lt;br&gt;
 4、有符号数 * 有符号数 = 有符号数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;236与237-乘除2的幂&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#236与237-乘除2的幂&#34;&gt;#&lt;/a&gt; 2.3.6 与 2.3.7  乘除 2 的幂&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B1bXBpL2FydGljbGUvZGV0YWlscy8xMDQ0OTc1Mjk=&#34;&gt;计算 2 的幂的解方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ2RqZHNqaC9wLzUwMzc2NzMuaHRtbCM6fjp0ZXh0PSVFNSU5QyVBOCVFNSVBNCVBNyVFNSVBNCU5QSVFNiU5NSVCMCVFNyU5QSU4NCVFNiU5QyVCQSVFNSU5OSVBOCVFNCVCOCVBRCVFRiVCQyU4QyVFOSU5OSVBNCVFNiVCMyU5NSVFOCVBNiU4MSVFNiVBRiU5NCVFNCVCOSU5OCVFNiVCMyU5NSVFOCVCRiU5OCVFNiU5QyU4OSVFNSU4QSVBMCVFNiVCMyU5NSVFOCVCRiU5OSVFNCVCQSU5Qg==&#34;&gt;具体解释 1&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQ0NjI1Mi9hcnRpY2xlL2RldGFpbHMvMTA5MzgwMDEx&#34;&gt;通过位运算来进行 2 的幂运算&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;24浮点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#24浮点&#34;&gt;#&lt;/a&gt; 2.4 浮点&lt;/h1&gt;
&lt;p&gt;用于精确的计算，提高运算精度。&lt;/p&gt;
&lt;h2 id=&#34;241-二进制小数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#241-二进制小数&#34;&gt;#&lt;/a&gt; 2.4.1  二进制小数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;与十进制类似，用科学计数法表示（以 2 作指数底数）。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分为整数与小数两个部分，常常要在运算中分离处理&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;二进制小数末尾添上 0 或去掉 0，小数的大小也不变，但是意义不一样。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;正二进制整数或小数的开头添上 0 或去掉 0，数的大小不变。负二进制整数或小数的开头添上 1 或去掉 1，数的大小也不变。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;242-ieee浮点表示&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#242-ieee浮点表示&#34;&gt;#&lt;/a&gt; 2.4.2  IEEE 浮点表示&lt;/h2&gt;
&lt;p&gt;IEEE 标准 754 规定了三种浮点数格式：单精度、双精度、扩展精度。前两者正好对应 C 语言里头的 float、double 或者 FORTRAN 里头的 real、double 精度类型。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk3OTMwNC9hcnRpY2xlL2RldGFpbHMvMTA4MDQ0NzU0&#34;&gt;详见&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;243-数值示例&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#243-数值示例&#34;&gt;#&lt;/a&gt; 2.4.3 数值示例&lt;/h2&gt;
&lt;p&gt;来日方长：详见 csapp  p87&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://cdn.jsdelivr.net/gh/TCworkor/images/img/202210171328815.png&#34; alt=&#34;截图20221002221650&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;244舍入&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#244舍入&#34;&gt;#&lt;/a&gt; 2.4.4 舍入&lt;/h2&gt;
&lt;p&gt;因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似表示实数运算。&lt;/p&gt;
&lt;p&gt;舍入运算，可以找到最接近的匹配值。（需要定义舍入方向）&lt;/p&gt;
&lt;p&gt;舍入会存在偏差，（向偶数舍入可以避免偏差）&lt;/p&gt;
&lt;h2 id=&#34;245-浮点运算&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#245-浮点运算&#34;&gt;#&lt;/a&gt; 2.4.5 浮点运算&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;浮点数的加减运算分为 5 个步骤：对阶、尾数相加、尾数规格化、尾数舍入处理、溢出判断处理。&lt;/p&gt;
&lt;h5 id=&#34;1-对阶所谓对阶就是让两个操作数阶数相同以便进行加减-实现的方式是对较小数的尾数进行右移操作-对阶的原则是向高阶看齐&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-对阶所谓对阶就是让两个操作数阶数相同以便进行加减-实现的方式是对较小数的尾数进行右移操作-对阶的原则是向高阶看齐&#34;&gt;#&lt;/a&gt; 1. 对阶：所谓对阶，就是让两个操作数阶数相同，以便进行加减。实现的方式是对较小数的尾数进行右移操作。对阶的原则是向高阶看齐。&lt;/h5&gt;
&lt;h5 id=&#34;2-尾数加减将两个操作数的尾数相加减-在ieee754标准中对于规格化数来说在小数点前有一位隐藏位1在加减过程中需要把它还原到尾数中-尾数加减的实质是原码的加减&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-尾数加减将两个操作数的尾数相加减-在ieee754标准中对于规格化数来说在小数点前有一位隐藏位1在加减过程中需要把它还原到尾数中-尾数加减的实质是原码的加减&#34;&gt;#&lt;/a&gt; 2. 尾数加减：将两个操作数的尾数相加减。在 IEEE754 标准中，对于规格化数来说在小数点前有一位隐藏位 1，在加减过程中需要把它还原到尾数中。尾数加减的实质是原码的加减，&lt;/h5&gt;
&lt;h5 id=&#34;3尾数规格化加减完成的尾数形式未必满足ieee754对于尾数的要求即保留23位小数点在第一个1之后-需要对尾数进行左规和右规下面介绍一下左规和右规-左规将尾数向左移用于清除第一个1前面出现的0-左规伴随着阶码减少在左规过程中要检测阶码是否发生下溢即阶码达到最小值0000-0000-右规将尾数向右移用于两数相加后出现向高位进位的情况-因为两数相加最多进一位所以右规最多一位-右规伴随着阶码的增加在右规过程中要检测阶码是否发生上溢即阶码达到最大值1111-1111&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#3尾数规格化加减完成的尾数形式未必满足ieee754对于尾数的要求即保留23位小数点在第一个1之后-需要对尾数进行左规和右规下面介绍一下左规和右规-左规将尾数向左移用于清除第一个1前面出现的0-左规伴随着阶码减少在左规过程中要检测阶码是否发生下溢即阶码达到最小值0000-0000-右规将尾数向右移用于两数相加后出现向高位进位的情况-因为两数相加最多进一位所以右规最多一位-右规伴随着阶码的增加在右规过程中要检测阶码是否发生上溢即阶码达到最大值1111-1111&#34;&gt;#&lt;/a&gt; 3. 尾数规格化：加减完成的尾数形式未必满足 IEEE754 对于尾数的要求，即保留 23 位，小数点在第一个 1 之后。需要对尾数进行左规和右规，下面介绍一下左规和右规。左规：将尾数向左移，用于清除第一个 1 前面出现的 0。左规伴随着阶码减少，在左规过程中要检测阶码是否发生下溢，即阶码达到最小值（0000 0000）。右规：将尾数向右移，用于两数相加后出现向高位进位的情况。因为两数相加最多进一位，所以右规最多一位。右规伴随着阶码的增加，在右规过程中要检测阶码是否发生上溢，即阶码达到最大值（1111 1111）。&lt;/h5&gt;
&lt;h5 id=&#34;&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#&#34;&gt;#&lt;/a&gt; &lt;/h5&gt;
&lt;h5 id=&#34;5-溢出判断-在浮点数中是以阶码的溢出与否来作为评判标准的-单精度溢出分为上溢指数大于等于127和下溢指数小于等于-126&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#5-溢出判断-在浮点数中是以阶码的溢出与否来作为评判标准的-单精度溢出分为上溢指数大于等于127和下溢指数小于等于-126&#34;&gt;#&lt;/a&gt; 5. 溢出判断：  在浮点数中是以阶码的溢出与否来作为评判标准的。单精度溢出分为上溢（指数大于等于 127）和下溢（指数小于等于 - 126)。&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详见：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dsc19udWFhL2FydGljbGUvZGV0YWlscy8xMDU0MDEzNzI=&#34;&gt;详见&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&#34;25-小结&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#25-小结&#34;&gt;#&lt;/a&gt; 2.5 小结&lt;/h1&gt;
&lt;p&gt;虽然有很多不懂，但是就当作练习使用 typora 吧。以后回来看这些笔记怎么说也有帮助吧。（±+）&lt;/p&gt;
</content>
        <category term="csapp" />
        <updated>2022-10-12T11:07:35.000Z</updated>
    </entry>
</feed>
